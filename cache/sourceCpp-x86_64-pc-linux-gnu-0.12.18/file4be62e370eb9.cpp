#include <exporter.h>
#include <RcppEigen.h>
// Code generated by Stan version 2.18.0

#include <stan/model/standalone_functions_header.hpp>

namespace user_cef2cb265cf917e6460cb551e02344a8 { 
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "unknown file name");
    reader.add_event(1443, 1441, "end", "unknown file name");
    return reader;
}

int
rle_elem_count(const std::vector<int>& set, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 20;
        int U(0);
        (void) U;  // dummy to suppress unused var warning

        stan::math::fill(U, std::numeric_limits<int>::min());


        current_statement_begin__ = 21;
        stan::math::assign(U, 1);
        current_statement_begin__ = 22;
        for (int i = 2; i <= num_elements(set); ++i) {

            current_statement_begin__ = 23;
            if (as_bool(logical_neq(get_base1(set,(i - 1),"set",1),get_base1(set,i,"set",1)))) {
                current_statement_begin__ = 24;
                stan::math::assign(U, stan::model::deep_copy((U + 1)));
            }
        }
        current_statement_begin__ = 26;
        return stan::math::promote_scalar<fun_return_scalar_t__>(U);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct rle_elem_count_functor__ {
            int
    operator()(const std::vector<int>& set, std::ostream* pstream__) const {
        return rle_elem_count(set, pstream__);
    }
};

std::vector<int>
rle_int(const std::vector<int>& set, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 31;
        validate_non_negative_index("res", "rle_elem_count(set, pstream__)", rle_elem_count(set, pstream__));
        vector<int> res(rle_elem_count(set, pstream__), 0);
        stan::math::fill(res, std::numeric_limits<int>::min());
        current_statement_begin__ = 32;
        int c(0);
        (void) c;  // dummy to suppress unused var warning

        stan::math::fill(c, std::numeric_limits<int>::min());


        current_statement_begin__ = 33;
        stan::model::assign(res, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    1, 
                    "assigning variable res");
        current_statement_begin__ = 34;
        stan::math::assign(c, 1);
        current_statement_begin__ = 35;
        for (int i = 2; i <= num_elements(set); ++i) {

            current_statement_begin__ = 36;
            if (as_bool(logical_eq(get_base1(set,(i - 1),"set",1),get_base1(set,i,"set",1)))) {

                current_statement_begin__ = 37;
                stan::model::assign(res, 
                            stan::model::cons_list(stan::model::index_uni(c), stan::model::nil_index_list()), 
                            stan::model::deep_copy((get_base1(res,c,"res",1) + 1)), 
                            "assigning variable res");
            } else {

                current_statement_begin__ = 39;
                stan::math::assign(c, stan::model::deep_copy((c + 1)));
                current_statement_begin__ = 40;
                stan::model::assign(res, 
                            stan::model::cons_list(stan::model::index_uni(c), stan::model::nil_index_list()), 
                            1, 
                            "assigning variable res");
            }
        }
        current_statement_begin__ = 43;
        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct rle_int_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& set, std::ostream* pstream__) const {
        return rle_int(set, pstream__);
    }
};

std::vector<int>
seq_int(const int& start,
            const int& end, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 48;
        int N(0);
        (void) N;  // dummy to suppress unused var warning

        stan::math::fill(N, std::numeric_limits<int>::min());
        stan::math::assign(N,((end - start) + 1));
        current_statement_begin__ = 49;
        validate_non_negative_index("seq", "N", N);
        vector<int> seq(N, 0);
        stan::math::fill(seq, std::numeric_limits<int>::min());


        current_statement_begin__ = 50;
        for (int i = 1; i <= N; ++i) {
            current_statement_begin__ = 50;
            stan::model::assign(seq, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        ((i + start) - 1), 
                        "assigning variable seq");
        }
        current_statement_begin__ = 51;
        return stan::math::promote_scalar<fun_return_scalar_t__>(seq);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct seq_int_functor__ {
            std::vector<int>
    operator()(const int& start,
            const int& end, std::ostream* pstream__) const {
        return seq_int(start, end, pstream__);
    }
};

std::vector<int>
rep_each(const std::vector<int>& set,
             const std::vector<int>& each, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 57;
        int N(0);
        (void) N;  // dummy to suppress unused var warning

        stan::math::fill(N, std::numeric_limits<int>::min());
        stan::math::assign(N,sum(each));
        current_statement_begin__ = 58;
        validate_non_negative_index("replicated", "N", N);
        vector<int> replicated(N, 0);
        stan::math::fill(replicated, std::numeric_limits<int>::min());
        current_statement_begin__ = 59;
        int p(0);
        (void) p;  // dummy to suppress unused var warning

        stan::math::fill(p, std::numeric_limits<int>::min());
        stan::math::assign(p,1);


        current_statement_begin__ = 61;
        for (int i = 1; i <= size(set); ++i) {

            current_statement_begin__ = 62;
            stan::model::assign(replicated, 
                        stan::model::cons_list(stan::model::index_min_max(p, ((p + get_base1(each,i,"each",1)) - 1)), stan::model::nil_index_list()), 
                        rep_array(get_base1(set,i,"set",1),get_base1(each,i,"each",1)), 
                        "assigning variable replicated");
            current_statement_begin__ = 63;
            stan::math::assign(p, stan::model::deep_copy((p + get_base1(each,i,"each",1))));
        }
        current_statement_begin__ = 66;
        return stan::math::promote_scalar<fun_return_scalar_t__>(replicated);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct rep_each_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& set,
             const std::vector<int>& each, std::ostream* pstream__) const {
        return rep_each(set, each, pstream__);
    }
};

template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
log_diff_exp_abs(const T0__& la,
                     const T1__& lb, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 80;
        return stan::math::promote_scalar<fun_return_scalar_t__>((0.5 * log_diff_exp(log_sum_exp((2 * la),(2 * lb)),((stan::math::log(2) + la) + lb))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct log_diff_exp_abs_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& la,
                     const T1__& lb, std::ostream* pstream__) const {
        return log_diff_exp_abs(la, lb, pstream__);
    }
};

template <typename T0__, typename T1__>
std::vector<int>
find_interval_slow(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                       const Eigen::Matrix<T1__, Eigen::Dynamic,1>& sorted, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 88;
        validate_non_negative_index("res", "num_elements(x)", num_elements(x));
        vector<int> res(num_elements(x), 0);
        stan::math::fill(res, std::numeric_limits<int>::min());


        current_statement_begin__ = 91;
        for (int i = 1; i <= num_elements(x); ++i) {

            current_statement_begin__ = 92;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        rank(append_row(rep_vector(get_base1(x,i,"x",1),1),sorted),1), 
                        "assigning variable res");
        }
        current_statement_begin__ = 94;
        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct find_interval_slow_functor__ {
    template <typename T0__, typename T1__>
        std::vector<int>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                       const Eigen::Matrix<T1__, Eigen::Dynamic,1>& sorted, std::ostream* pstream__) const {
        return find_interval_slow(x, sorted, pstream__);
    }
};

template <typename T0__, typename T1__>
int
find_interval_elem(const T0__& x,
                       const Eigen::Matrix<T1__, Eigen::Dynamic,1>& sorted,
                       const int& start_ind, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 100;
        int res(0);
        (void) res;  // dummy to suppress unused var warning

        stan::math::fill(res, std::numeric_limits<int>::min());
        current_statement_begin__ = 101;
        int N(0);
        (void) N;  // dummy to suppress unused var warning

        stan::math::fill(N, std::numeric_limits<int>::min());
        current_statement_begin__ = 102;
        int max_iter(0);
        (void) max_iter;  // dummy to suppress unused var warning

        stan::math::fill(max_iter, std::numeric_limits<int>::min());
        current_statement_begin__ = 103;
        local_scalar_t__ left;
        (void) left;  // dummy to suppress unused var warning

        stan::math::initialize(left, DUMMY_VAR__);
        stan::math::fill(left,DUMMY_VAR__);
        current_statement_begin__ = 104;
        local_scalar_t__ right;
        (void) right;  // dummy to suppress unused var warning

        stan::math::initialize(right, DUMMY_VAR__);
        stan::math::fill(right,DUMMY_VAR__);
        current_statement_begin__ = 105;
        int left_ind(0);
        (void) left_ind;  // dummy to suppress unused var warning

        stan::math::fill(left_ind, std::numeric_limits<int>::min());
        current_statement_begin__ = 106;
        int right_ind(0);
        (void) right_ind;  // dummy to suppress unused var warning

        stan::math::fill(right_ind, std::numeric_limits<int>::min());
        current_statement_begin__ = 107;
        int iter(0);
        (void) iter;  // dummy to suppress unused var warning

        stan::math::fill(iter, std::numeric_limits<int>::min());


        current_statement_begin__ = 109;
        stan::math::assign(N, num_elements(sorted));
        current_statement_begin__ = 111;
        if (as_bool(logical_eq(N,0))) {
            current_statement_begin__ = 111;
            return stan::math::promote_scalar<fun_return_scalar_t__>(0);
        }
        current_statement_begin__ = 113;
        stan::math::assign(left_ind, start_ind);
        current_statement_begin__ = 114;
        stan::math::assign(right_ind, N);
        current_statement_begin__ = 116;
        stan::math::assign(max_iter, (100 * N));
        current_statement_begin__ = 117;
        stan::math::assign(left, (get_base1(sorted,left_ind,"sorted",1) - x));
        current_statement_begin__ = 118;
        stan::math::assign(right, (get_base1(sorted,right_ind,"sorted",1) - x));
        current_statement_begin__ = 120;
        if (as_bool(logical_lte(0,left))) {
            current_statement_begin__ = 120;
            return stan::math::promote_scalar<fun_return_scalar_t__>((left_ind - 1));
        }
        current_statement_begin__ = 121;
        if (as_bool(logical_eq(0,right))) {
            current_statement_begin__ = 121;
            return stan::math::promote_scalar<fun_return_scalar_t__>((N - 1));
        }
        current_statement_begin__ = 122;
        if (as_bool(logical_gt(0,right))) {
            current_statement_begin__ = 122;
            return stan::math::promote_scalar<fun_return_scalar_t__>(N);
        }
        current_statement_begin__ = 124;
        stan::math::assign(iter, 1);
        current_statement_begin__ = 125;
        while (as_bool((primitive_value(logical_gt((right_ind - left_ind),1)) && primitive_value(logical_neq(iter,max_iter))))) {
            {
            current_statement_begin__ = 126;
            int mid_ind(0);
            (void) mid_ind;  // dummy to suppress unused var warning

            stan::math::fill(mid_ind, std::numeric_limits<int>::min());
            current_statement_begin__ = 127;
            local_scalar_t__ mid;
            (void) mid;  // dummy to suppress unused var warning

            stan::math::initialize(mid, DUMMY_VAR__);
            stan::math::fill(mid,DUMMY_VAR__);


            current_statement_begin__ = 130;
            stan::math::assign(mid_ind, divide((left_ind + right_ind),2));
            current_statement_begin__ = 131;
            stan::math::assign(mid, (get_base1(sorted,mid_ind,"sorted",1) - x));
            current_statement_begin__ = 132;
            if (as_bool(logical_eq(mid,0))) {
                current_statement_begin__ = 132;
                return stan::math::promote_scalar<fun_return_scalar_t__>((mid_ind - 1));
            }
            current_statement_begin__ = 133;
            if (as_bool(logical_lt((left * mid),0))) {

                current_statement_begin__ = 133;
                stan::math::assign(right, mid);
                current_statement_begin__ = 133;
                stan::math::assign(right_ind, mid_ind);
            }
            current_statement_begin__ = 134;
            if (as_bool(logical_lt((right * mid),0))) {

                current_statement_begin__ = 134;
                stan::math::assign(left, mid);
                current_statement_begin__ = 134;
                stan::math::assign(left_ind, mid_ind);
            }
            current_statement_begin__ = 135;
            stan::math::assign(iter, stan::model::deep_copy((iter + 1)));
            }
        }
        current_statement_begin__ = 137;
        if (as_bool(logical_eq(iter,max_iter))) {
            current_statement_begin__ = 138;
            if (pstream__) {
                stan_print(pstream__,"Maximum number of iterations reached.");
                *pstream__ << std::endl;
            }
        }
        current_statement_begin__ = 139;
        return stan::math::promote_scalar<fun_return_scalar_t__>(left_ind);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct find_interval_elem_functor__ {
    template <typename T0__, typename T1__>
        int
    operator()(const T0__& x,
                       const Eigen::Matrix<T1__, Eigen::Dynamic,1>& sorted,
                       const int& start_ind, std::ostream* pstream__) const {
        return find_interval_elem(x, sorted, start_ind, pstream__);
    }
};

template <typename T0__, typename T1__>
std::vector<int>
find_interval(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                  const Eigen::Matrix<T1__, Eigen::Dynamic,1>& sorted, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 143;
        validate_non_negative_index("res", "num_elements(x)", num_elements(x));
        vector<int> res(num_elements(x), 0);
        stan::math::fill(res, std::numeric_limits<int>::min());


        current_statement_begin__ = 144;
        for (int i = 1; i <= num_elements(x); ++i) {

            current_statement_begin__ = 145;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        find_interval_elem(get_base1(x,i,"x",1),sorted,1, pstream__), 
                        "assigning variable res");
        }
        current_statement_begin__ = 147;
        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct find_interval_functor__ {
    template <typename T0__, typename T1__>
        std::vector<int>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                  const Eigen::Matrix<T1__, Eigen::Dynamic,1>& sorted, std::ostream* pstream__) const {
        return find_interval(x, sorted, pstream__);
    }
};

template <typename T0__, typename T1__>
std::vector<int>
find_interval_asc(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                      const Eigen::Matrix<T1__, Eigen::Dynamic,1>& sorted, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 153;
        validate_non_negative_index("res", "num_elements(x)", num_elements(x));
        vector<int> res(num_elements(x), 0);
        stan::math::fill(res, std::numeric_limits<int>::min());
        current_statement_begin__ = 154;
        int last(0);
        (void) last;  // dummy to suppress unused var warning

        stan::math::fill(last, std::numeric_limits<int>::min());


        current_statement_begin__ = 155;
        stan::math::assign(last, 1);
        current_statement_begin__ = 156;
        for (int i = 1; i <= num_elements(x); ++i) {

            current_statement_begin__ = 157;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        find_interval_elem(get_base1(x,i,"x",1),sorted,last, pstream__), 
                        "assigning variable res");
            current_statement_begin__ = 158;
            if (as_bool(logical_gt(get_base1(res,i,"res",1),0))) {
                current_statement_begin__ = 158;
                stan::math::assign(last, get_base1(res,i,"res",1));
            }
        }
        current_statement_begin__ = 160;
        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct find_interval_asc_functor__ {
    template <typename T0__, typename T1__>
        std::vector<int>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& x,
                      const Eigen::Matrix<T1__, Eigen::Dynamic,1>& sorted, std::ostream* pstream__) const {
        return find_interval_asc(x, sorted, pstream__);
    }
};

template <typename T1__, typename T3__>
std::vector<int>
find_interval_blocked(const std::vector<int>& vals_M,
                          const Eigen::Matrix<T1__, Eigen::Dynamic,1>& vals,
                          const std::vector<int>& sorted_M,
                          const Eigen::Matrix<T3__, Eigen::Dynamic,1>& sorted, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T3__>::type local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 164;
        validate_non_negative_index("res", "num_elements(vals)", num_elements(vals));
        vector<int> res(num_elements(vals), 0);
        stan::math::fill(res, std::numeric_limits<int>::min());
        current_statement_begin__ = 165;
        int M(0);
        (void) M;  // dummy to suppress unused var warning

        stan::math::fill(M, std::numeric_limits<int>::min());
        current_statement_begin__ = 166;
        int v(0);
        (void) v;  // dummy to suppress unused var warning

        stan::math::fill(v, std::numeric_limits<int>::min());
        current_statement_begin__ = 167;
        int s(0);
        (void) s;  // dummy to suppress unused var warning

        stan::math::fill(s, std::numeric_limits<int>::min());


        current_statement_begin__ = 168;
        stan::math::assign(M, num_elements(vals_M));
        current_statement_begin__ = 169;
        stan::math::assign(v, 1);
        current_statement_begin__ = 170;
        stan::math::assign(s, 1);
        current_statement_begin__ = 171;
        for (int m = 1; m <= M; ++m) {
            {
            current_statement_begin__ = 172;
            validate_non_negative_index("temp", "get_base1(vals_M,m,\"vals_M\",1)", get_base1(vals_M,m,"vals_M",1));
            vector<int> temp(get_base1(vals_M,m,"vals_M",1), 0);
            stan::math::fill(temp, std::numeric_limits<int>::min());


            current_statement_begin__ = 173;
            stan::math::assign(temp, find_interval(segment(vals,v,get_base1(vals_M,m,"vals_M",1)),segment(sorted,s,get_base1(sorted_M,m,"sorted_M",1)), pstream__));
            current_statement_begin__ = 174;
            for (int n = 1; n <= get_base1(vals_M,m,"vals_M",1); ++n) {
                current_statement_begin__ = 175;
                stan::model::assign(res, 
                            stan::model::cons_list(stan::model::index_uni(((v + n) - 1)), stan::model::nil_index_list()), 
                            get_base1(temp,n,"temp",1), 
                            "assigning variable res");
            }
            current_statement_begin__ = 176;
            stan::math::assign(v, stan::model::deep_copy((v + get_base1(vals_M,m,"vals_M",1))));
            current_statement_begin__ = 177;
            stan::math::assign(s, stan::model::deep_copy((s + get_base1(sorted_M,m,"sorted_M",1))));
            }
        }
        current_statement_begin__ = 179;
        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct find_interval_blocked_functor__ {
    template <typename T1__, typename T3__>
        std::vector<int>
    operator()(const std::vector<int>& vals_M,
                          const Eigen::Matrix<T1__, Eigen::Dynamic,1>& vals,
                          const std::vector<int>& sorted_M,
                          const Eigen::Matrix<T3__, Eigen::Dynamic,1>& sorted, std::ostream* pstream__) const {
        return find_interval_blocked(vals_M, vals, sorted_M, sorted, pstream__);
    }
};

int
count_elem(const std::vector<int>& test,
               const int& elem, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 184;
        int count(0);
        (void) count;  // dummy to suppress unused var warning

        stan::math::fill(count, std::numeric_limits<int>::min());


        current_statement_begin__ = 185;
        stan::math::assign(count, 0);
        current_statement_begin__ = 186;
        for (int i = 1; i <= num_elements(test); ++i) {
            current_statement_begin__ = 187;
            if (as_bool(logical_eq(get_base1(test,i,"test",1),elem))) {
                current_statement_begin__ = 188;
                stan::math::assign(count, stan::model::deep_copy((count + 1)));
            }
        }
        current_statement_begin__ = 189;
        return stan::math::promote_scalar<fun_return_scalar_t__>(count);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct count_elem_functor__ {
            int
    operator()(const std::vector<int>& test,
               const int& elem, std::ostream* pstream__) const {
        return count_elem(test, elem, pstream__);
    }
};

std::vector<int>
count_elems(const std::vector<int>& test,
                const std::vector<int>& elems, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 194;
        validate_non_negative_index("counts", "num_elements(elems)", num_elements(elems));
        vector<int> counts(num_elements(elems), 0);
        stan::math::fill(counts, std::numeric_limits<int>::min());


        current_statement_begin__ = 195;
        for (int i = 1; i <= num_elements(elems); ++i) {
            current_statement_begin__ = 196;
            stan::model::assign(counts, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        count_elem(test,get_base1(elems,i,"elems",1), pstream__), 
                        "assigning variable counts");
        }
        current_statement_begin__ = 197;
        return stan::math::promote_scalar<fun_return_scalar_t__>(counts);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct count_elems_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& test,
                const std::vector<int>& elems, std::ostream* pstream__) const {
        return count_elems(test, elems, pstream__);
    }
};

std::vector<int>
which_elem(const std::vector<int>& test,
               const int& elem, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 202;
        validate_non_negative_index("res", "count_elem(test,elem, pstream__)", count_elem(test,elem, pstream__));
        vector<int> res(count_elem(test,elem, pstream__), 0);
        stan::math::fill(res, std::numeric_limits<int>::min());
        current_statement_begin__ = 203;
        int ci(0);
        (void) ci;  // dummy to suppress unused var warning

        stan::math::fill(ci, std::numeric_limits<int>::min());


        current_statement_begin__ = 204;
        stan::math::assign(ci, 1);
        current_statement_begin__ = 205;
        for (int i = 1; i <= num_elements(test); ++i) {
            current_statement_begin__ = 206;
            if (as_bool(logical_eq(get_base1(test,i,"test",1),elem))) {

                current_statement_begin__ = 207;
                stan::model::assign(res, 
                            stan::model::cons_list(stan::model::index_uni(ci), stan::model::nil_index_list()), 
                            i, 
                            "assigning variable res");
                current_statement_begin__ = 208;
                stan::math::assign(ci, stan::model::deep_copy((ci + 1)));
            }
        }
        current_statement_begin__ = 210;
        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct which_elem_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& test,
               const int& elem, std::ostream* pstream__) const {
        return which_elem(test, elem, pstream__);
    }
};

template <typename T0__, typename T1__>
int
floor_div_int(const T0__& fac,
                  const T1__& div, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 215;
        int count(0);
        (void) count;  // dummy to suppress unused var warning

        stan::math::fill(count, std::numeric_limits<int>::min());


        current_statement_begin__ = 216;
        if (as_bool(logical_lt(fac,0))) {
            current_statement_begin__ = 217;
            std::stringstream errmsg_stream__;
            errmsg_stream__ << "floor_div_int only works for positive values.";
            throw std::domain_error(errmsg_stream__.str());
        }
        current_statement_begin__ = 218;
        stan::math::assign(count, 1);
        current_statement_begin__ = 219;
        while (as_bool(logical_lte((count * div),fac))) {

            current_statement_begin__ = 219;
            stan::math::assign(count, stan::model::deep_copy((count + 1)));
        }
        current_statement_begin__ = 220;
        stan::math::assign(count, stan::model::deep_copy((count - 1)));
        current_statement_begin__ = 221;
        return stan::math::promote_scalar<fun_return_scalar_t__>(count);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct floor_div_int_functor__ {
    template <typename T0__, typename T1__>
        int
    operator()(const T0__& fac,
                  const T1__& div, std::ostream* pstream__) const {
        return floor_div_int(fac, div, pstream__);
    }
};

std::vector<int>
count_obs_event_free(const std::vector<int>& obs_timeRank,
                         const int& ndose, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 225;
        validate_non_negative_index("dose_next_obs", "ndose", ndose);
        vector<int> dose_next_obs(ndose, 0);
        stan::math::fill(dose_next_obs, std::numeric_limits<int>::min());
        current_statement_begin__ = 226;
        int o(0);
        (void) o;  // dummy to suppress unused var warning

        stan::math::fill(o, std::numeric_limits<int>::min());
        current_statement_begin__ = 227;
        int O(0);
        (void) O;  // dummy to suppress unused var warning

        stan::math::fill(O, std::numeric_limits<int>::min());


        current_statement_begin__ = 228;
        stan::math::assign(dose_next_obs, rep_array(0,ndose));
        current_statement_begin__ = 229;
        stan::math::assign(o, 0);
        current_statement_begin__ = 230;
        stan::math::assign(O, size(obs_timeRank));
        current_statement_begin__ = 231;
        while (as_bool((primitive_value(logical_lt(o,O)) && primitive_value(logical_eq(get_base1(obs_timeRank,(o + 1),"obs_timeRank",1),0))))) {

            current_statement_begin__ = 231;
            stan::math::assign(o, stan::model::deep_copy((o + 1)));
        }
        current_statement_begin__ = 232;
        for (int i = 1; i <= ndose; ++i) {
            {
            current_statement_begin__ = 233;
            int count(0);
            (void) count;  // dummy to suppress unused var warning

            stan::math::fill(count, std::numeric_limits<int>::min());


            current_statement_begin__ = 234;
            stan::math::assign(count, 0);
            current_statement_begin__ = 235;
            while (as_bool((primitive_value(logical_lt(o,O)) && primitive_value(logical_eq(get_base1(obs_timeRank,(o + 1),"obs_timeRank",1),i))))) {

                current_statement_begin__ = 236;
                stan::math::assign(o, stan::model::deep_copy((o + 1)));
                current_statement_begin__ = 237;
                stan::math::assign(count, stan::model::deep_copy((count + 1)));
            }
            current_statement_begin__ = 239;
            stan::model::assign(dose_next_obs, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        count, 
                        "assigning variable dose_next_obs");
            }
        }
        current_statement_begin__ = 241;
        return stan::math::promote_scalar<fun_return_scalar_t__>(dose_next_obs);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct count_obs_event_free_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& obs_timeRank,
                         const int& ndose, std::ostream* pstream__) const {
        return count_obs_event_free(obs_timeRank, ndose, pstream__);
    }
};

std::vector<int>
count_obs_event_free_blocked(const std::vector<int>& M,
                                 const std::vector<int>& obs_timeRank,
                                 const std::vector<int>& ndose, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 245;
        validate_non_negative_index("dose_next_obs", "sum(ndose)", sum(ndose));
        vector<int> dose_next_obs(sum(ndose), 0);
        stan::math::fill(dose_next_obs, std::numeric_limits<int>::min());
        current_statement_begin__ = 246;
        int l(0);
        (void) l;  // dummy to suppress unused var warning

        stan::math::fill(l, std::numeric_limits<int>::min());
        current_statement_begin__ = 247;
        int ld(0);
        (void) ld;  // dummy to suppress unused var warning

        stan::math::fill(ld, std::numeric_limits<int>::min());


        current_statement_begin__ = 248;
        stan::math::assign(dose_next_obs, rep_array(0,sum(ndose)));
        current_statement_begin__ = 249;
        stan::math::assign(l, 1);
        current_statement_begin__ = 250;
        stan::math::assign(ld, 1);
        current_statement_begin__ = 251;
        for (int i = 1; i <= size(M); ++i) {
            {
            current_statement_begin__ = 252;
            int u(0);
            (void) u;  // dummy to suppress unused var warning

            stan::math::fill(u, std::numeric_limits<int>::min());
            current_statement_begin__ = 253;
            int ud(0);
            (void) ud;  // dummy to suppress unused var warning

            stan::math::fill(ud, std::numeric_limits<int>::min());


            current_statement_begin__ = 254;
            stan::math::assign(u, ((l + get_base1(M,i,"M",1)) - 1));
            current_statement_begin__ = 255;
            stan::math::assign(ud, ((ld + get_base1(ndose,i,"ndose",1)) - 1));
            current_statement_begin__ = 256;
            stan::model::assign(dose_next_obs, 
                        stan::model::cons_list(stan::model::index_min_max(ld, ud), stan::model::nil_index_list()), 
                        count_obs_event_free(stan::model::rvalue(obs_timeRank, stan::model::cons_list(stan::model::index_min_max(l, u), stan::model::nil_index_list()), "obs_timeRank"),get_base1(ndose,i,"ndose",1), pstream__), 
                        "assigning variable dose_next_obs");
            current_statement_begin__ = 257;
            stan::math::assign(l, (u + 1));
            current_statement_begin__ = 258;
            stan::math::assign(ld, (ud + 1));
            }
        }
        current_statement_begin__ = 260;
        return stan::math::promote_scalar<fun_return_scalar_t__>(dose_next_obs);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct count_obs_event_free_blocked_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& M,
                                 const std::vector<int>& obs_timeRank,
                                 const std::vector<int>& ndose, std::ostream* pstream__) const {
        return count_obs_event_free_blocked(M, obs_timeRank, ndose, pstream__);
    }
};

std::vector<int>
subset_int(const std::vector<int>& cand,
               const std::vector<int>& ind_set, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 268;
        validate_non_negative_index("out", "size(ind_set)", size(ind_set));
        vector<int> out(size(ind_set), 0);
        stan::math::fill(out, std::numeric_limits<int>::min());


        current_statement_begin__ = 269;
        for (int i = 1; i <= size(ind_set); ++i) {
            current_statement_begin__ = 270;
            stan::model::assign(out, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        get_base1(cand,get_base1(ind_set,i,"ind_set",1),"cand",1), 
                        "assigning variable out");
        }
        current_statement_begin__ = 271;
        return stan::math::promote_scalar<fun_return_scalar_t__>(out);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct subset_int_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& cand,
               const std::vector<int>& ind_set, std::ostream* pstream__) const {
        return subset_int(cand, ind_set, pstream__);
    }
};

template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
subset_vec(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& cand,
               const std::vector<int>& ind_set, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 275;
        validate_non_negative_index("out", "size(ind_set)", size(ind_set));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  out(static_cast<Eigen::VectorXd::Index>(size(ind_set)));
        (void) out;  // dummy to suppress unused var warning

        stan::math::initialize(out, DUMMY_VAR__);
        stan::math::fill(out,DUMMY_VAR__);


        current_statement_begin__ = 276;
        for (int i = 1; i <= size(ind_set); ++i) {
            current_statement_begin__ = 277;
            stan::model::assign(out, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        get_base1(cand,get_base1(ind_set,i,"ind_set",1),"cand",1), 
                        "assigning variable out");
        }
        current_statement_begin__ = 278;
        return stan::math::promote_scalar<fun_return_scalar_t__>(out);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct subset_vec_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& cand,
               const std::vector<int>& ind_set, std::ostream* pstream__) const {
        return subset_vec(cand, ind_set, pstream__);
    }
};

template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
subset_matrix(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& cand,
                  const std::vector<int>& ind_set, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 282;
        validate_non_negative_index("out", "size(ind_set)", size(ind_set));
        validate_non_negative_index("out", "cols(cand)", cols(cand));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  out(static_cast<Eigen::VectorXd::Index>(size(ind_set)),static_cast<Eigen::VectorXd::Index>(cols(cand)));
        (void) out;  // dummy to suppress unused var warning

        stan::math::initialize(out, DUMMY_VAR__);
        stan::math::fill(out,DUMMY_VAR__);


        current_statement_begin__ = 283;
        for (int i = 1; i <= size(ind_set); ++i) {
            current_statement_begin__ = 284;
            stan::model::assign(out, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        get_base1(cand,get_base1(ind_set,i,"ind_set",1),"cand",1), 
                        "assigning variable out");
        }
        current_statement_begin__ = 285;
        return stan::math::promote_scalar<fun_return_scalar_t__>(out);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct subset_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,Eigen::Dynamic>& cand,
                  const std::vector<int>& ind_set, std::ostream* pstream__) const {
        return subset_matrix(cand, ind_set, pstream__);
    }
};

void
check_ids(const std::vector<int>& id, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 291;
        int cid(0);
        (void) cid;  // dummy to suppress unused var warning

        stan::math::fill(cid, std::numeric_limits<int>::min());
        stan::math::assign(cid,0);
        current_statement_begin__ = 292;
        int warned(0);
        (void) warned;  // dummy to suppress unused var warning

        stan::math::fill(warned, std::numeric_limits<int>::min());
        stan::math::assign(warned,0);


        current_statement_begin__ = 293;
        stan::math::assign(cid, 0);
        current_statement_begin__ = 294;
        for (int n = 1; n <= num_elements(id); ++n) {

            current_statement_begin__ = 295;
            if (as_bool(logical_neq(get_base1(id,n,"id",1),cid))) {

                current_statement_begin__ = 296;
                if (as_bool(logical_neq(get_base1(id,n,"id",1),(cid + 1)))) {

                    current_statement_begin__ = 297;
                    if (as_bool(logical_negation(warned))) {
                        current_statement_begin__ = 298;
                        if (pstream__) {
                            stan_print(pstream__,"WARNING: id vector not correctly sorted, i.e. not in range 1..J. Consider using the cid vector internally.");
                            *pstream__ << std::endl;
                        }
                    }
                    current_statement_begin__ = 299;
                    stan::math::assign(warned, 1);
                } else {

                    current_statement_begin__ = 301;
                    stan::math::assign(cid, stan::model::deep_copy((cid + 1)));
                }
            }
        }
        current_statement_begin__ = 305;
        if (as_bool(logical_neq(max(id),cid))) {
            current_statement_begin__ = 306;
            if (pstream__) {
                stan_print(pstream__,"WARNING: Last patient\'s id not equal to max(id).");
                *pstream__ << std::endl;
            }
        }
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct check_ids_functor__ {
            void
    operator()(const std::vector<int>& id, std::ostream* pstream__) const {
        return check_ids(id, pstream__);
    }
};

template <typename T0__, typename T1__>
void
check_addl_dosing(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& dose_time,
                      const Eigen::Matrix<T1__, Eigen::Dynamic,1>& dose_tau,
                      const std::vector<int>& dose_addl, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 313;
        int D(0);
        (void) D;  // dummy to suppress unused var warning

        stan::math::fill(D, std::numeric_limits<int>::min());
        stan::math::assign(D,num_elements(dose_time));


        current_statement_begin__ = 315;
        for (int d = 2; d <= D; ++d) {

            current_statement_begin__ = 316;
            if (as_bool(logical_lt(get_base1(dose_time,d,"dose_time",1),(get_base1(dose_time,(d - 1),"dose_time",1) + (get_base1(dose_tau,(d - 1),"dose_tau",1) * get_base1(dose_addl,(d - 1),"dose_addl",1)))))) {
                current_statement_begin__ = 317;
                std::stringstream errmsg_stream__;
                errmsg_stream__ << "Forbidden overlapping dosing records found.";
                throw std::domain_error(errmsg_stream__.str());
            }
        }
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct check_addl_dosing_functor__ {
    template <typename T0__, typename T1__>
        void
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& dose_time,
                      const Eigen::Matrix<T1__, Eigen::Dynamic,1>& dose_tau,
                      const std::vector<int>& dose_addl, std::ostream* pstream__) const {
        return check_addl_dosing(dose_time, dose_tau, dose_addl, pstream__);
    }
};

template <typename T1__, typename T2__>
void
check_addl_dosing_blocked(const std::vector<int>& dose_M,
                              const Eigen::Matrix<T1__, Eigen::Dynamic,1>& dose_time,
                              const Eigen::Matrix<T2__, Eigen::Dynamic,1>& dose_tau,
                              const std::vector<int>& dose_addl, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 322;
        int M(0);
        (void) M;  // dummy to suppress unused var warning

        stan::math::fill(M, std::numeric_limits<int>::min());
        stan::math::assign(M,num_elements(dose_M));
        current_statement_begin__ = 323;
        int b(0);
        (void) b;  // dummy to suppress unused var warning

        stan::math::fill(b, std::numeric_limits<int>::min());
        stan::math::assign(b,1);


        current_statement_begin__ = 324;
        for (int m = 1; m <= M; ++m) {

            current_statement_begin__ = 325;
            check_addl_dosing(segment(dose_time,b,get_base1(dose_M,m,"dose_M",1)),segment(dose_tau,b,get_base1(dose_M,m,"dose_M",1)),segment(dose_addl,b,get_base1(dose_M,m,"dose_M",1)), pstream__);
            current_statement_begin__ = 328;
            stan::math::assign(b, stan::model::deep_copy((b + get_base1(dose_M,m,"dose_M",1))));
        }
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct check_addl_dosing_blocked_functor__ {
    template <typename T1__, typename T2__>
        void
    operator()(const std::vector<int>& dose_M,
                              const Eigen::Matrix<T1__, Eigen::Dynamic,1>& dose_time,
                              const Eigen::Matrix<T2__, Eigen::Dynamic,1>& dose_tau,
                              const std::vector<int>& dose_addl, std::ostream* pstream__) const {
        return check_addl_dosing_blocked(dose_M, dose_time, dose_tau, dose_addl, pstream__);
    }
};

std::vector<int>
make_slice_index(const std::vector<int>& S, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 340;
        validate_non_negative_index("Si", "(size(S) + 1)", (size(S) + 1));
        vector<int> Si((size(S) + 1), 0);
        stan::math::fill(Si, std::numeric_limits<int>::min());
        current_statement_begin__ = 341;
        int cv(0);
        (void) cv;  // dummy to suppress unused var warning

        stan::math::fill(cv, std::numeric_limits<int>::min());
        stan::math::assign(cv,1);


        current_statement_begin__ = 342;
        stan::model::assign(Si, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    cv, 
                    "assigning variable Si");
        current_statement_begin__ = 343;
        for (int i = 1; i <= size(S); ++i) {

            current_statement_begin__ = 344;
            stan::math::assign(cv, stan::model::deep_copy((cv + get_base1(S,i,"S",1))));
            current_statement_begin__ = 345;
            stan::model::assign(Si, 
                        stan::model::cons_list(stan::model::index_uni((i + 1)), stan::model::nil_index_list()), 
                        cv, 
                        "assigning variable Si");
        }
        current_statement_begin__ = 347;
        return stan::math::promote_scalar<fun_return_scalar_t__>(Si);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct make_slice_index_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& S, std::ostream* pstream__) const {
        return make_slice_index(S, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__>
std::vector<int>
count_dose_given(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& time,
                     const Eigen::Matrix<T1__, Eigen::Dynamic,1>& dose_time,
                     const Eigen::Matrix<T2__, Eigen::Dynamic,1>& dose_tau,
                     const std::vector<int>& dose_addl, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 351;
        validate_non_negative_index("dose_count", "num_elements(time)", num_elements(time));
        vector<int> dose_count(num_elements(time), 0);
        stan::math::fill(dose_count, std::numeric_limits<int>::min());
        current_statement_begin__ = 352;
        validate_non_negative_index("time_rank", "num_elements(time)", num_elements(time));
        vector<int> time_rank(num_elements(time), 0);
        stan::math::fill(time_rank, std::numeric_limits<int>::min());
        current_statement_begin__ = 353;
        int o(0);
        (void) o;  // dummy to suppress unused var warning

        stan::math::fill(o, std::numeric_limits<int>::min());
        current_statement_begin__ = 354;
        int O(0);
        (void) O;  // dummy to suppress unused var warning

        stan::math::fill(O, std::numeric_limits<int>::min());


        current_statement_begin__ = 355;
        stan::math::assign(o, 1);
        current_statement_begin__ = 356;
        stan::math::assign(O, num_elements(time));
        current_statement_begin__ = 357;
        stan::math::assign(time_rank, find_interval(time,dose_time, pstream__));
        current_statement_begin__ = 358;
        stan::math::assign(dose_count, rep_array(0,O));
        current_statement_begin__ = 361;
        while (as_bool((primitive_value(logical_lt(o,O)) && primitive_value(logical_eq(get_base1(time_rank,o,"time_rank",1),0))))) {

            current_statement_begin__ = 361;
            stan::math::assign(o, stan::model::deep_copy((o + 1)));
        }
        current_statement_begin__ = 363;
        for (int i = o; i <= O; ++i) {
            {
            current_statement_begin__ = 364;
            int d(0);
            (void) d;  // dummy to suppress unused var warning

            stan::math::fill(d, std::numeric_limits<int>::min());


            current_statement_begin__ = 365;
            stan::math::assign(d, get_base1(time_rank,i,"time_rank",1));
            current_statement_begin__ = 366;
            if (as_bool(logical_gt(get_base1(dose_tau,d,"dose_tau",1),0))) {
                current_statement_begin__ = 367;
                stan::model::assign(dose_count, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                            std::min(floor_div_int((get_base1(time,i,"time",1) - get_base1(dose_time,d,"dose_time",1)),get_base1(dose_tau,d,"dose_tau",1), pstream__),get_base1(dose_addl,d,"dose_addl",1)), 
                            "assigning variable dose_count");
            }
            }
        }
        current_statement_begin__ = 369;
        return stan::math::promote_scalar<fun_return_scalar_t__>(dose_count);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct count_dose_given_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        std::vector<int>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& time,
                     const Eigen::Matrix<T1__, Eigen::Dynamic,1>& dose_time,
                     const Eigen::Matrix<T2__, Eigen::Dynamic,1>& dose_tau,
                     const std::vector<int>& dose_addl, std::ostream* pstream__) const {
        return count_dose_given(time, dose_time, dose_tau, dose_addl, pstream__);
    }
};

template <typename T1__, typename T3__, typename T4__>
std::vector<int>
count_dose_given_blocked(const std::vector<int>& M,
                             const Eigen::Matrix<T1__, Eigen::Dynamic,1>& time,
                             const std::vector<int>& M_dose,
                             const Eigen::Matrix<T3__, Eigen::Dynamic,1>& dose_time,
                             const Eigen::Matrix<T4__, Eigen::Dynamic,1>& dose_tau,
                             const std::vector<int>& dose_addl, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T3__, T4__>::type local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 373;
        validate_non_negative_index("dose_count", "num_elements(time)", num_elements(time));
        vector<int> dose_count(num_elements(time), 0);
        stan::math::fill(dose_count, std::numeric_limits<int>::min());
        current_statement_begin__ = 374;
        int B(0);
        (void) B;  // dummy to suppress unused var warning

        stan::math::fill(B, std::numeric_limits<int>::min());
        current_statement_begin__ = 375;
        int tl(0);
        (void) tl;  // dummy to suppress unused var warning

        stan::math::fill(tl, std::numeric_limits<int>::min());
        current_statement_begin__ = 376;
        int dl(0);
        (void) dl;  // dummy to suppress unused var warning

        stan::math::fill(dl, std::numeric_limits<int>::min());


        current_statement_begin__ = 377;
        stan::math::assign(B, num_elements(M));
        current_statement_begin__ = 378;
        stan::math::assign(tl, 1);
        current_statement_begin__ = 379;
        stan::math::assign(dl, 1);
        current_statement_begin__ = 380;
        for (int b = 1; b <= B; ++b) {
            {
            current_statement_begin__ = 381;
            int tu(0);
            (void) tu;  // dummy to suppress unused var warning

            stan::math::fill(tu, std::numeric_limits<int>::min());
            current_statement_begin__ = 382;
            int du(0);
            (void) du;  // dummy to suppress unused var warning

            stan::math::fill(du, std::numeric_limits<int>::min());


            current_statement_begin__ = 383;
            stan::math::assign(tu, ((tl + get_base1(M,b,"M",1)) - 1));
            current_statement_begin__ = 384;
            stan::math::assign(du, ((dl + get_base1(M_dose,b,"M_dose",1)) - 1));
            current_statement_begin__ = 385;
            stan::model::assign(dose_count, 
                        stan::model::cons_list(stan::model::index_min_max(tl, tu), stan::model::nil_index_list()), 
                        count_dose_given(stan::model::rvalue(time, stan::model::cons_list(stan::model::index_min_max(tl, tu), stan::model::nil_index_list()), "time"),stan::model::rvalue(dose_time, stan::model::cons_list(stan::model::index_min_max(dl, du), stan::model::nil_index_list()), "dose_time"),stan::model::rvalue(dose_tau, stan::model::cons_list(stan::model::index_min_max(dl, du), stan::model::nil_index_list()), "dose_tau"),stan::model::rvalue(dose_addl, stan::model::cons_list(stan::model::index_min_max(dl, du), stan::model::nil_index_list()), "dose_addl"), pstream__), 
                        "assigning variable dose_count");
            current_statement_begin__ = 386;
            stan::math::assign(tl, (tu + 1));
            current_statement_begin__ = 387;
            stan::math::assign(dl, (du + 1));
            }
        }
        current_statement_begin__ = 389;
        return stan::math::promote_scalar<fun_return_scalar_t__>(dose_count);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct count_dose_given_blocked_functor__ {
    template <typename T1__, typename T3__, typename T4__>
        std::vector<int>
    operator()(const std::vector<int>& M,
                             const Eigen::Matrix<T1__, Eigen::Dynamic,1>& time,
                             const std::vector<int>& M_dose,
                             const Eigen::Matrix<T3__, Eigen::Dynamic,1>& dose_time,
                             const Eigen::Matrix<T4__, Eigen::Dynamic,1>& dose_tau,
                             const std::vector<int>& dose_addl, std::ostream* pstream__) const {
        return count_dose_given_blocked(M, time, M_dose, dose_time, dose_tau, dose_addl, pstream__);
    }
};

template <typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__>::type, Eigen::Dynamic,Eigen::Dynamic>
evolve_lsystem(const int& S,
                   const Eigen::Matrix<T1__, Eigen::Dynamic,1>& Dt,
                   const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& coefs,
                   const std::vector<int>& coefs_map, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 405;
        validate_non_negative_index("lsystem", "num_elements(Dt)", num_elements(Dt));
        validate_non_negative_index("lsystem", "S", S);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  lsystem(static_cast<Eigen::VectorXd::Index>(num_elements(Dt)),static_cast<Eigen::VectorXd::Index>(S));
        (void) lsystem;  // dummy to suppress unused var warning

        stan::math::initialize(lsystem, DUMMY_VAR__);
        stan::math::fill(lsystem,DUMMY_VAR__);
        current_statement_begin__ = 406;
        int T(0);
        (void) T;  // dummy to suppress unused var warning

        stan::math::fill(T, std::numeric_limits<int>::min());


        current_statement_begin__ = 407;
        stan::math::assign(T, num_elements(Dt));
        current_statement_begin__ = 410;
        stan::math::assign(lsystem, rep_matrix(-(500),T,S));
        current_statement_begin__ = 412;
        for (int o = 1; o <= cols(coefs); ++o) {
            {
            current_statement_begin__ = 413;
            int s(0);
            (void) s;  // dummy to suppress unused var warning

            stan::math::fill(s, std::numeric_limits<int>::min());
            current_statement_begin__ = 414;
            validate_non_negative_index("term", "T", T);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  term(static_cast<Eigen::VectorXd::Index>(T));
            (void) term;  // dummy to suppress unused var warning

            stan::math::initialize(term, DUMMY_VAR__);
            stan::math::fill(term,DUMMY_VAR__);


            current_statement_begin__ = 415;
            stan::math::assign(s, get_base1(coefs_map,o,"coefs_map",1));
            current_statement_begin__ = 416;
            stan::math::assign(term, add(get_base1(coefs,1,o,"coefs",1),multiply(Dt,get_base1(coefs,2,o,"coefs",1))));
            current_statement_begin__ = 417;
            for (int t = 1; t <= T; ++t) {
                current_statement_begin__ = 418;
                stan::model::assign(lsystem, 
                            stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(s), stan::model::nil_index_list())), 
                            stan::model::deep_copy(log_sum_exp(get_base1(lsystem,t,s,"lsystem",1),get_base1(term,t,"term",1))), 
                            "assigning variable lsystem");
            }
            }
        }
        current_statement_begin__ = 420;
        return stan::math::promote_scalar<fun_return_scalar_t__>(lsystem);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct evolve_lsystem_functor__ {
    template <typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const int& S,
                   const Eigen::Matrix<T1__, Eigen::Dynamic,1>& Dt,
                   const Eigen::Matrix<T2__, Eigen::Dynamic,Eigen::Dynamic>& coefs,
                   const std::vector<int>& coefs_map, std::ostream* pstream__) const {
        return evolve_lsystem(S, Dt, coefs, coefs_map, pstream__);
    }
};

template <typename T0__>
typename boost::math::tools::promote_args<T0__>::type
lgeometric_series(const T0__& la,
                      const int& n, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 424;
        return stan::math::promote_scalar<fun_return_scalar_t__>((log1m_exp((la * n)) - log1m_exp(la)));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct lgeometric_series_functor__ {
    template <typename T0__>
        typename boost::math::tools::promote_args<T0__>::type
    operator()(const T0__& la,
                      const int& n, std::ostream* pstream__) const {
        return lgeometric_series(la, n, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
pk_1cmt_metabolite_depot(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& lref,
                             const Eigen::Matrix<T1__, Eigen::Dynamic,1>& Dt,
                             const T2__& lk1,
                             const T3__& lk12,
                             const T4__& lk20,
                             const T5__& tau,
                             const int& n, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 440;
        validate_non_negative_index("coefs1", "2", 2);
        validate_non_negative_index("coefs1", "8", 8);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  coefs1(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(8));
        (void) coefs1;  // dummy to suppress unused var warning

        stan::math::initialize(coefs1, DUMMY_VAR__);
        stan::math::fill(coefs1,DUMMY_VAR__);
        current_statement_begin__ = 441;
        validate_non_negative_index("coefs1_map", "8", 8);
        vector<int> coefs1_map(8, 0);
        stan::math::fill(coefs1_map, std::numeric_limits<int>::min());
        current_statement_begin__ = 442;
        validate_non_negative_index("coefs1_zero", "8", 8);
        vector<int> coefs1_zero(8, 0);
        stan::math::fill(coefs1_zero, std::numeric_limits<int>::min());
        current_statement_begin__ = 443;
        validate_non_negative_index("coefs2", "2", 2);
        validate_non_negative_index("coefs2", "6", 6);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  coefs2(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(6));
        (void) coefs2;  // dummy to suppress unused var warning

        stan::math::initialize(coefs2, DUMMY_VAR__);
        stan::math::fill(coefs2,DUMMY_VAR__);
        current_statement_begin__ = 444;
        validate_non_negative_index("coefs2_map", "6", 6);
        vector<int> coefs2_map(6, 0);
        stan::math::fill(coefs2_map, std::numeric_limits<int>::min());
        current_statement_begin__ = 445;
        validate_non_negative_index("coefs2_zero", "6", 6);
        vector<int> coefs2_zero(6, 0);
        stan::math::fill(coefs2_zero, std::numeric_limits<int>::min());
        current_statement_begin__ = 447;
        validate_non_negative_index("lsystem1", "num_elements(Dt)", num_elements(Dt));
        validate_non_negative_index("lsystem1", "3", 3);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  lsystem1(static_cast<Eigen::VectorXd::Index>(num_elements(Dt)),static_cast<Eigen::VectorXd::Index>(3));
        (void) lsystem1;  // dummy to suppress unused var warning

        stan::math::initialize(lsystem1, DUMMY_VAR__);
        stan::math::fill(lsystem1,DUMMY_VAR__);
        current_statement_begin__ = 449;
        validate_non_negative_index("lsystem2", "num_elements(Dt)", num_elements(Dt));
        validate_non_negative_index("lsystem2", "2", 2);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  lsystem2(static_cast<Eigen::VectorXd::Index>(num_elements(Dt)),static_cast<Eigen::VectorXd::Index>(2));
        (void) lsystem2;  // dummy to suppress unused var warning

        stan::math::initialize(lsystem2, DUMMY_VAR__);
        stan::math::fill(lsystem2,DUMMY_VAR__);
        current_statement_begin__ = 450;
        local_scalar_t__ ldeltaSq;
        (void) ldeltaSq;  // dummy to suppress unused var warning

        stan::math::initialize(ldeltaSq, DUMMY_VAR__);
        stan::math::fill(ldeltaSq,DUMMY_VAR__);
        current_statement_begin__ = 451;
        local_scalar_t__ nk1;
        (void) nk1;  // dummy to suppress unused var warning

        stan::math::initialize(nk1, DUMMY_VAR__);
        stan::math::fill(nk1,DUMMY_VAR__);
        current_statement_begin__ = 452;
        local_scalar_t__ nk20;
        (void) nk20;  // dummy to suppress unused var warning

        stan::math::initialize(nk20, DUMMY_VAR__);
        stan::math::fill(nk20,DUMMY_VAR__);


        current_statement_begin__ = 454;
        stan::math::assign(coefs1_zero, rep_array(0,8));
        current_statement_begin__ = 455;
        stan::math::assign(coefs2_zero, rep_array(0,6));
        current_statement_begin__ = 457;
        stan::math::assign(ldeltaSq, (2 * log_diff_exp_abs(lk1,lk20, pstream__)));
        current_statement_begin__ = 459;
        stan::math::assign(nk1, -(stan::math::exp(lk1)));
        current_statement_begin__ = 460;
        stan::math::assign(nk20, -(stan::math::exp(lk20)));
        current_statement_begin__ = 463;
        stan::model::assign(coefs1_map, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    1, 
                    "assigning variable coefs1_map");
        current_statement_begin__ = 464;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    get_base1(lref,1,"lref",1), 
                    "assigning variable coefs1");
        current_statement_begin__ = 465;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    nk1, 
                    "assigning variable coefs1");
        current_statement_begin__ = 467;
        stan::model::assign(coefs1_map, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list()), 
                    2, 
                    "assigning variable coefs1_map");
        current_statement_begin__ = 468;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    (((get_base1(lref,1,"lref",1) + lk12) - ldeltaSq) + lk1), 
                    "assigning variable coefs1");
        current_statement_begin__ = 469;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    nk20, 
                    "assigning variable coefs1");
        current_statement_begin__ = 470;
        stan::model::assign(coefs1_map, 
                    stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list()), 
                    2, 
                    "assigning variable coefs1_map");
        current_statement_begin__ = 471;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                    (((get_base1(lref,1,"lref",1) + lk12) - ldeltaSq) + lk20), 
                    "assigning variable coefs1");
        current_statement_begin__ = 472;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                    nk1, 
                    "assigning variable coefs1");
        current_statement_begin__ = 474;
        stan::model::assign(coefs1_map, 
                    stan::model::cons_list(stan::model::index_uni(4), stan::model::nil_index_list()), 
                    2, 
                    "assigning variable coefs1_map");
        current_statement_begin__ = 475;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(4), stan::model::nil_index_list())), 
                    get_base1(lref,2,"lref",1), 
                    "assigning variable coefs1");
        current_statement_begin__ = 476;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(4), stan::model::nil_index_list())), 
                    nk20, 
                    "assigning variable coefs1");
        current_statement_begin__ = 479;
        stan::model::assign(coefs1_map, 
                    stan::model::cons_list(stan::model::index_uni(5), stan::model::nil_index_list()), 
                    3, 
                    "assigning variable coefs1_map");
        current_statement_begin__ = 480;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(5), stan::model::nil_index_list())), 
                    log_sum_exp(get_base1(lref,3,"lref",1),get_base1(lref,2,"lref",1)), 
                    "assigning variable coefs1");
        current_statement_begin__ = 481;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(5), stan::model::nil_index_list())), 
                    0, 
                    "assigning variable coefs1");
        current_statement_begin__ = 482;
        stan::model::assign(coefs1_zero, 
                    stan::model::cons_list(stan::model::index_uni(5), stan::model::nil_index_list()), 
                    1, 
                    "assigning variable coefs1_zero");
        current_statement_begin__ = 484;
        stan::model::assign(coefs1_map, 
                    stan::model::cons_list(stan::model::index_uni(6), stan::model::nil_index_list()), 
                    3, 
                    "assigning variable coefs1_map");
        current_statement_begin__ = 485;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(6), stan::model::nil_index_list())), 
                    ((((get_base1(lref,1,"lref",1) + lk12) + lk20) - ldeltaSq) + log_sum_exp((lk1 - lk20),(lk20 - lk1))), 
                    "assigning variable coefs1");
        current_statement_begin__ = 486;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(6), stan::model::nil_index_list())), 
                    0, 
                    "assigning variable coefs1");
        current_statement_begin__ = 487;
        stan::model::assign(coefs1_zero, 
                    stan::model::cons_list(stan::model::index_uni(6), stan::model::nil_index_list()), 
                    1, 
                    "assigning variable coefs1_zero");
        current_statement_begin__ = 489;
        stan::model::assign(coefs1_map, 
                    stan::model::cons_list(stan::model::index_uni(7), stan::model::nil_index_list()), 
                    3, 
                    "assigning variable coefs1_map");
        current_statement_begin__ = 490;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(7), stan::model::nil_index_list())), 
                    (((get_base1(lref,1,"lref",1) + lk12) + lk20) - ldeltaSq), 
                    "assigning variable coefs1");
        current_statement_begin__ = 491;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(7), stan::model::nil_index_list())), 
                    nk1, 
                    "assigning variable coefs1");
        current_statement_begin__ = 493;
        stan::model::assign(coefs1_map, 
                    stan::model::cons_list(stan::model::index_uni(8), stan::model::nil_index_list()), 
                    3, 
                    "assigning variable coefs1_map");
        current_statement_begin__ = 494;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(8), stan::model::nil_index_list())), 
                    (((get_base1(lref,1,"lref",1) + lk12) + lk20) - ldeltaSq), 
                    "assigning variable coefs1");
        current_statement_begin__ = 495;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(8), stan::model::nil_index_list())), 
                    nk20, 
                    "assigning variable coefs1");
        current_statement_begin__ = 499;
        stan::model::assign(coefs2_map, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    1, 
                    "assigning variable coefs2_map");
        current_statement_begin__ = 500;
        stan::model::assign(coefs2, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    (((get_base1(lref,1,"lref",1) + lk12) - ldeltaSq) + lk1), 
                    "assigning variable coefs2");
        current_statement_begin__ = 501;
        stan::model::assign(coefs2, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    nk1, 
                    "assigning variable coefs2");
        current_statement_begin__ = 502;
        stan::model::assign(coefs2_map, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list()), 
                    1, 
                    "assigning variable coefs2_map");
        current_statement_begin__ = 503;
        stan::model::assign(coefs2, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    (((get_base1(lref,1,"lref",1) + lk12) - ldeltaSq) + lk20), 
                    "assigning variable coefs2");
        current_statement_begin__ = 504;
        stan::model::assign(coefs2, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    nk20, 
                    "assigning variable coefs2");
        current_statement_begin__ = 506;
        stan::model::assign(coefs2_map, 
                    stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list()), 
                    2, 
                    "assigning variable coefs2_map");
        current_statement_begin__ = 507;
        stan::model::assign(coefs2, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                    get_base1(lref,2,"lref",1), 
                    "assigning variable coefs2");
        current_statement_begin__ = 508;
        stan::model::assign(coefs2, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                    nk20, 
                    "assigning variable coefs2");
        current_statement_begin__ = 510;
        stan::model::assign(coefs2_map, 
                    stan::model::cons_list(stan::model::index_uni(4), stan::model::nil_index_list()), 
                    2, 
                    "assigning variable coefs2_map");
        current_statement_begin__ = 511;
        stan::model::assign(coefs2, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(4), stan::model::nil_index_list())), 
                    ((((get_base1(lref,1,"lref",1) + lk12) - ldeltaSq) + lk20) + stan::math::log(2)), 
                    "assigning variable coefs2");
        current_statement_begin__ = 512;
        stan::model::assign(coefs2, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(4), stan::model::nil_index_list())), 
                    0, 
                    "assigning variable coefs2");
        current_statement_begin__ = 513;
        stan::model::assign(coefs2_zero, 
                    stan::model::cons_list(stan::model::index_uni(4), stan::model::nil_index_list()), 
                    1, 
                    "assigning variable coefs2_zero");
        current_statement_begin__ = 515;
        stan::model::assign(coefs2_map, 
                    stan::model::cons_list(stan::model::index_uni(5), stan::model::nil_index_list()), 
                    2, 
                    "assigning variable coefs2_map");
        current_statement_begin__ = 516;
        stan::model::assign(coefs2, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(5), stan::model::nil_index_list())), 
                    (((((get_base1(lref,1,"lref",1) + lk12) - ldeltaSq) + lk20) + lk1) - lk20), 
                    "assigning variable coefs2");
        current_statement_begin__ = 517;
        stan::model::assign(coefs2, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(5), stan::model::nil_index_list())), 
                    nk20, 
                    "assigning variable coefs2");
        current_statement_begin__ = 519;
        stan::model::assign(coefs2_map, 
                    stan::model::cons_list(stan::model::index_uni(6), stan::model::nil_index_list()), 
                    2, 
                    "assigning variable coefs2_map");
        current_statement_begin__ = 520;
        stan::model::assign(coefs2, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(6), stan::model::nil_index_list())), 
                    (((((get_base1(lref,1,"lref",1) + lk12) - ldeltaSq) + lk20) + lk20) - lk1), 
                    "assigning variable coefs2");
        current_statement_begin__ = 521;
        stan::model::assign(coefs2, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(6), stan::model::nil_index_list())), 
                    nk1, 
                    "assigning variable coefs2");
        current_statement_begin__ = 526;
        if (as_bool(logical_gt(n,1))) {
            {
            current_statement_begin__ = 527;
            local_scalar_t__ logn;
            (void) logn;  // dummy to suppress unused var warning

            stan::math::initialize(logn, DUMMY_VAR__);
            stan::math::fill(logn,DUMMY_VAR__);


            current_statement_begin__ = 528;
            stan::math::assign(logn, stan::math::log(n));
            current_statement_begin__ = 529;
            for (int i = 1; i <= 8; ++i) {

                current_statement_begin__ = 530;
                if (as_bool(get_base1(coefs1_zero,i,"coefs1_zero",1))) {

                    current_statement_begin__ = 531;
                    stan::model::assign(coefs1, 
                                stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                                stan::model::deep_copy((get_base1(coefs1,1,i,"coefs1",1) + logn)), 
                                "assigning variable coefs1");
                } else {

                    current_statement_begin__ = 533;
                    stan::model::assign(coefs1, 
                                stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                                stan::model::deep_copy((get_base1(coefs1,1,i,"coefs1",1) + lgeometric_series((get_base1(coefs1,2,i,"coefs1",1) * tau),n, pstream__))), 
                                "assigning variable coefs1");
                }
            }
            current_statement_begin__ = 536;
            for (int i = 1; i <= 6; ++i) {

                current_statement_begin__ = 537;
                if (as_bool(get_base1(coefs2_zero,i,"coefs2_zero",1))) {

                    current_statement_begin__ = 538;
                    stan::model::assign(coefs2, 
                                stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                                stan::model::deep_copy((get_base1(coefs2,1,i,"coefs2",1) + logn)), 
                                "assigning variable coefs2");
                } else {

                    current_statement_begin__ = 540;
                    stan::model::assign(coefs2, 
                                stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                                stan::model::deep_copy((get_base1(coefs2,1,i,"coefs2",1) + lgeometric_series((get_base1(coefs2,2,i,"coefs2",1) * tau),n, pstream__))), 
                                "assigning variable coefs2");
                }
            }
            }
        }
        current_statement_begin__ = 548;
        stan::math::assign(lsystem1, evolve_lsystem(3,Dt,coefs1,coefs1_map, pstream__));
        current_statement_begin__ = 549;
        stan::math::assign(lsystem2, evolve_lsystem(2,Dt,coefs2,coefs2_map, pstream__));
        current_statement_begin__ = 555;
        for (int t = 1; t <= num_elements(Dt); ++t) {

            current_statement_begin__ = 556;
            stan::model::assign(lsystem1, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                        stan::model::deep_copy(log_diff_exp(get_base1(lsystem1,t,2,"lsystem1",1),get_base1(lsystem2,t,1,"lsystem2",1))), 
                        "assigning variable lsystem1");
            current_statement_begin__ = 557;
            stan::model::assign(lsystem1, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                        stan::model::deep_copy(log_diff_exp(get_base1(lsystem1,t,3,"lsystem1",1),get_base1(lsystem2,t,2,"lsystem2",1))), 
                        "assigning variable lsystem1");
        }
        current_statement_begin__ = 560;
        return stan::math::promote_scalar<fun_return_scalar_t__>(lsystem1);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct pk_1cmt_metabolite_depot_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& lref,
                             const Eigen::Matrix<T1__, Eigen::Dynamic,1>& Dt,
                             const T2__& lk1,
                             const T3__& lk12,
                             const T4__& lk20,
                             const T5__& tau,
                             const int& n, std::ostream* pstream__) const {
        return pk_1cmt_metabolite_depot(lref, Dt, lk1, lk12, lk20, tau, n, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
pk_1cmt_metabolite(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& lref,
                       const Eigen::Matrix<T1__, Eigen::Dynamic,1>& Dt,
                       const T2__& lk1,
                       const T3__& lk12,
                       const T4__& lk20,
                       const T5__& tau,
                       const int& n, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 565;
        validate_non_negative_index("coefs1", "2", 2);
        validate_non_negative_index("coefs1", "4", 4);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  coefs1(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(4));
        (void) coefs1;  // dummy to suppress unused var warning

        stan::math::initialize(coefs1, DUMMY_VAR__);
        stan::math::fill(coefs1,DUMMY_VAR__);
        current_statement_begin__ = 566;
        validate_non_negative_index("coefs1_map", "4", 4);
        vector<int> coefs1_map(4, 0);
        stan::math::fill(coefs1_map, std::numeric_limits<int>::min());
        current_statement_begin__ = 567;
        validate_non_negative_index("coefs2", "2", 2);
        validate_non_negative_index("coefs2", "2", 2);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  coefs2(static_cast<Eigen::VectorXd::Index>(2),static_cast<Eigen::VectorXd::Index>(2));
        (void) coefs2;  // dummy to suppress unused var warning

        stan::math::initialize(coefs2, DUMMY_VAR__);
        stan::math::fill(coefs2,DUMMY_VAR__);
        current_statement_begin__ = 568;
        validate_non_negative_index("coefs2_map", "2", 2);
        vector<int> coefs2_map(2, 0);
        stan::math::fill(coefs2_map, std::numeric_limits<int>::min());
        current_statement_begin__ = 570;
        validate_non_negative_index("lsystem1", "num_elements(Dt)", num_elements(Dt));
        validate_non_negative_index("lsystem1", "2", 2);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  lsystem1(static_cast<Eigen::VectorXd::Index>(num_elements(Dt)),static_cast<Eigen::VectorXd::Index>(2));
        (void) lsystem1;  // dummy to suppress unused var warning

        stan::math::initialize(lsystem1, DUMMY_VAR__);
        stan::math::fill(lsystem1,DUMMY_VAR__);
        current_statement_begin__ = 572;
        validate_non_negative_index("lsystem2", "num_elements(Dt)", num_elements(Dt));
        validate_non_negative_index("lsystem2", "1", 1);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  lsystem2(static_cast<Eigen::VectorXd::Index>(num_elements(Dt)),static_cast<Eigen::VectorXd::Index>(1));
        (void) lsystem2;  // dummy to suppress unused var warning

        stan::math::initialize(lsystem2, DUMMY_VAR__);
        stan::math::fill(lsystem2,DUMMY_VAR__);
        current_statement_begin__ = 573;
        local_scalar_t__ ldeltaSq;
        (void) ldeltaSq;  // dummy to suppress unused var warning

        stan::math::initialize(ldeltaSq, DUMMY_VAR__);
        stan::math::fill(ldeltaSq,DUMMY_VAR__);
        current_statement_begin__ = 574;
        local_scalar_t__ nk1;
        (void) nk1;  // dummy to suppress unused var warning

        stan::math::initialize(nk1, DUMMY_VAR__);
        stan::math::fill(nk1,DUMMY_VAR__);
        current_statement_begin__ = 575;
        local_scalar_t__ nk20;
        (void) nk20;  // dummy to suppress unused var warning

        stan::math::initialize(nk20, DUMMY_VAR__);
        stan::math::fill(nk20,DUMMY_VAR__);


        current_statement_begin__ = 577;
        stan::math::assign(ldeltaSq, (2 * log_diff_exp_abs(lk1,lk20, pstream__)));
        current_statement_begin__ = 579;
        stan::math::assign(nk1, -(stan::math::exp(lk1)));
        current_statement_begin__ = 580;
        stan::math::assign(nk20, -(stan::math::exp(lk20)));
        current_statement_begin__ = 583;
        stan::model::assign(coefs1_map, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    1, 
                    "assigning variable coefs1_map");
        current_statement_begin__ = 584;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    get_base1(lref,1,"lref",1), 
                    "assigning variable coefs1");
        current_statement_begin__ = 585;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    nk1, 
                    "assigning variable coefs1");
        current_statement_begin__ = 587;
        stan::model::assign(coefs1_map, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list()), 
                    2, 
                    "assigning variable coefs1_map");
        current_statement_begin__ = 588;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    (((get_base1(lref,1,"lref",1) + lk12) - ldeltaSq) + lk1), 
                    "assigning variable coefs1");
        current_statement_begin__ = 589;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    nk20, 
                    "assigning variable coefs1");
        current_statement_begin__ = 590;
        stan::model::assign(coefs1_map, 
                    stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list()), 
                    2, 
                    "assigning variable coefs1_map");
        current_statement_begin__ = 591;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                    (((get_base1(lref,1,"lref",1) + lk12) - ldeltaSq) + lk20), 
                    "assigning variable coefs1");
        current_statement_begin__ = 592;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                    nk1, 
                    "assigning variable coefs1");
        current_statement_begin__ = 594;
        stan::model::assign(coefs1_map, 
                    stan::model::cons_list(stan::model::index_uni(4), stan::model::nil_index_list()), 
                    2, 
                    "assigning variable coefs1_map");
        current_statement_begin__ = 595;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(4), stan::model::nil_index_list())), 
                    get_base1(lref,2,"lref",1), 
                    "assigning variable coefs1");
        current_statement_begin__ = 596;
        stan::model::assign(coefs1, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(4), stan::model::nil_index_list())), 
                    nk20, 
                    "assigning variable coefs1");
        current_statement_begin__ = 600;
        stan::model::assign(coefs2_map, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    1, 
                    "assigning variable coefs2_map");
        current_statement_begin__ = 601;
        stan::model::assign(coefs2, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    (((get_base1(lref,1,"lref",1) + lk12) - ldeltaSq) + lk1), 
                    "assigning variable coefs2");
        current_statement_begin__ = 602;
        stan::model::assign(coefs2, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    nk1, 
                    "assigning variable coefs2");
        current_statement_begin__ = 603;
        stan::model::assign(coefs2_map, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list()), 
                    1, 
                    "assigning variable coefs2_map");
        current_statement_begin__ = 604;
        stan::model::assign(coefs2, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    (((get_base1(lref,1,"lref",1) + lk12) - ldeltaSq) + lk20), 
                    "assigning variable coefs2");
        current_statement_begin__ = 605;
        stan::model::assign(coefs2, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    nk20, 
                    "assigning variable coefs2");
        current_statement_begin__ = 610;
        if (as_bool(logical_gt(n,1))) {

            current_statement_begin__ = 611;
            for (int i = 1; i <= 4; ++i) {

                current_statement_begin__ = 612;
                stan::model::assign(coefs1, 
                            stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                            stan::model::deep_copy((get_base1(coefs1,1,i,"coefs1",1) + lgeometric_series((get_base1(coefs1,2,i,"coefs1",1) * tau),n, pstream__))), 
                            "assigning variable coefs1");
            }
            current_statement_begin__ = 614;
            for (int i = 1; i <= 2; ++i) {

                current_statement_begin__ = 615;
                stan::model::assign(coefs2, 
                            stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                            stan::model::deep_copy((get_base1(coefs2,1,i,"coefs2",1) + lgeometric_series((get_base1(coefs2,2,i,"coefs2",1) * tau),n, pstream__))), 
                            "assigning variable coefs2");
            }
        }
        current_statement_begin__ = 622;
        stan::math::assign(lsystem1, evolve_lsystem(2,Dt,coefs1,coefs1_map, pstream__));
        current_statement_begin__ = 623;
        stan::math::assign(lsystem2, evolve_lsystem(1,Dt,coefs2,coefs2_map, pstream__));
        current_statement_begin__ = 629;
        for (int t = 1; t <= num_elements(Dt); ++t) {

            current_statement_begin__ = 630;
            stan::model::assign(lsystem1, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                        stan::model::deep_copy(log_diff_exp(get_base1(lsystem1,t,2,"lsystem1",1),get_base1(lsystem2,t,1,"lsystem2",1))), 
                        "assigning variable lsystem1");
        }
        current_statement_begin__ = 633;
        return stan::math::promote_scalar<fun_return_scalar_t__>(lsystem1);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct pk_1cmt_metabolite_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& lref,
                       const Eigen::Matrix<T1__, Eigen::Dynamic,1>& Dt,
                       const T2__& lk1,
                       const T3__& lk12,
                       const T4__& lk20,
                       const T5__& tau,
                       const int& n, std::ostream* pstream__) const {
        return pk_1cmt_metabolite(lref, Dt, lk1, lk12, lk20, tau, n, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic,1>
pk_1cmt_metabolite_metrics(const T0__& tau,
                               const T1__& lk1,
                               const T2__& lk12,
                               const T3__& lk20, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 660;
        validate_non_negative_index("metrics", "3", 3);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  metrics(static_cast<Eigen::VectorXd::Index>(3));
        (void) metrics;  // dummy to suppress unused var warning

        stan::math::initialize(metrics, DUMMY_VAR__);
        stan::math::fill(metrics,DUMMY_VAR__);
        current_statement_begin__ = 661;
        local_scalar_t__ k1;
        (void) k1;  // dummy to suppress unused var warning

        stan::math::initialize(k1, DUMMY_VAR__);
        stan::math::fill(k1,DUMMY_VAR__);
        current_statement_begin__ = 662;
        local_scalar_t__ k20;
        (void) k20;  // dummy to suppress unused var warning

        stan::math::initialize(k20, DUMMY_VAR__);
        stan::math::fill(k20,DUMMY_VAR__);


        current_statement_begin__ = 664;
        stan::math::assign(k1, stan::math::exp(lk1));
        current_statement_begin__ = 665;
        stan::math::assign(k20, stan::math::exp(lk20));
        current_statement_begin__ = 668;
        stan::model::assign(metrics, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    (-(log1m_exp((-(k1) * tau))) - (k1 * tau)), 
                    "assigning variable metrics");
        current_statement_begin__ = 671;
        stan::model::assign(metrics, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list()), 
                    ((lk12 - log_diff_exp_abs(lk1,lk20, pstream__)) + log_diff_exp_abs(((-(k20) * tau) - log1m_exp((-(k20) * tau))),((-(k1) * tau) - log1m_exp((-(k1) * tau))), pstream__)), 
                    "assigning variable metrics");
        current_statement_begin__ = 676;
        stan::model::assign(metrics, 
                    stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list()), 
                    -(log1m_exp((-(k1) * tau))), 
                    "assigning variable metrics");
        current_statement_begin__ = 678;
        return stan::math::promote_scalar<fun_return_scalar_t__>(metrics);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct pk_1cmt_metabolite_metrics_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic,1>
    operator()(const T0__& tau,
                               const T1__& lk1,
                               const T2__& lk12,
                               const T3__& lk20, std::ostream* pstream__) const {
        return pk_1cmt_metabolite_metrics(tau, lk1, lk12, lk20, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
pk_oral_2cmt(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& state0,
                 const Eigen::Matrix<T1__, Eigen::Dynamic,1>& Dt,
                 const T2__& lka,
                 const T3__& lalphaR,
                 const T4__& lbetaR,
                 const T5__& lA,
                 const T6__& lB, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 695;
        local_scalar_t__ lstateRefOral;
        (void) lstateRefOral;  // dummy to suppress unused var warning

        stan::math::initialize(lstateRefOral, DUMMY_VAR__);
        stan::math::fill(lstateRefOral,DUMMY_VAR__);
        current_statement_begin__ = 696;
        validate_non_negative_index("lstateRef", "2", 2);
        vector<local_scalar_t__> lstateRef(2);
        stan::math::initialize(lstateRef, DUMMY_VAR__);
        stan::math::fill(lstateRef,DUMMY_VAR__);
        current_statement_begin__ = 697;
        int N(0);
        (void) N;  // dummy to suppress unused var warning

        stan::math::fill(N, std::numeric_limits<int>::min());
        current_statement_begin__ = 698;
        local_scalar_t__ alphaR;
        (void) alphaR;  // dummy to suppress unused var warning

        stan::math::initialize(alphaR, DUMMY_VAR__);
        stan::math::fill(alphaR,DUMMY_VAR__);
        current_statement_begin__ = 699;
        local_scalar_t__ betaR;
        (void) betaR;  // dummy to suppress unused var warning

        stan::math::initialize(betaR, DUMMY_VAR__);
        stan::math::fill(betaR,DUMMY_VAR__);
        current_statement_begin__ = 700;
        local_scalar_t__ ka;
        (void) ka;  // dummy to suppress unused var warning

        stan::math::initialize(ka, DUMMY_VAR__);
        stan::math::fill(ka,DUMMY_VAR__);
        current_statement_begin__ = 701;
        local_scalar_t__ lAt;
        (void) lAt;  // dummy to suppress unused var warning

        stan::math::initialize(lAt, DUMMY_VAR__);
        stan::math::fill(lAt,DUMMY_VAR__);
        current_statement_begin__ = 702;
        local_scalar_t__ lBt;
        (void) lBt;  // dummy to suppress unused var warning

        stan::math::initialize(lBt, DUMMY_VAR__);
        stan::math::fill(lBt,DUMMY_VAR__);
        current_statement_begin__ = 703;
        validate_non_negative_index("lstate", "num_elements(Dt)", num_elements(Dt));
        validate_non_negative_index("lstate", "3", 3);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  lstate(static_cast<Eigen::VectorXd::Index>(num_elements(Dt)),static_cast<Eigen::VectorXd::Index>(3));
        (void) lstate;  // dummy to suppress unused var warning

        stan::math::initialize(lstate, DUMMY_VAR__);
        stan::math::fill(lstate,DUMMY_VAR__);
        current_statement_begin__ = 704;
        local_scalar_t__ lk12;
        (void) lk12;  // dummy to suppress unused var warning

        stan::math::initialize(lk12, DUMMY_VAR__);
        stan::math::fill(lk12,DUMMY_VAR__);
        current_statement_begin__ = 705;
        local_scalar_t__ lk21;
        (void) lk21;  // dummy to suppress unused var warning

        stan::math::initialize(lk21, DUMMY_VAR__);
        stan::math::fill(lk21,DUMMY_VAR__);
        current_statement_begin__ = 706;
        local_scalar_t__ lD;
        (void) lD;  // dummy to suppress unused var warning

        stan::math::initialize(lD, DUMMY_VAR__);
        stan::math::fill(lD,DUMMY_VAR__);
        current_statement_begin__ = 707;
        local_scalar_t__ lad2;
        (void) lad2;  // dummy to suppress unused var warning

        stan::math::initialize(lad2, DUMMY_VAR__);
        stan::math::fill(lad2,DUMMY_VAR__);
        current_statement_begin__ = 708;
        local_scalar_t__ lbd2;
        (void) lbd2;  // dummy to suppress unused var warning

        stan::math::initialize(lbd2, DUMMY_VAR__);
        stan::math::fill(lbd2,DUMMY_VAR__);
        current_statement_begin__ = 709;
        local_scalar_t__ ltemp;
        (void) ltemp;  // dummy to suppress unused var warning

        stan::math::initialize(ltemp, DUMMY_VAR__);
        stan::math::fill(ltemp,DUMMY_VAR__);


        current_statement_begin__ = 711;
        stan::math::assign(N, num_elements(Dt));
        current_statement_begin__ = 713;
        stan::math::assign(ka, stan::math::exp(lka));
        current_statement_begin__ = 714;
        stan::math::assign(alphaR, stan::math::exp(lalphaR));
        current_statement_begin__ = 715;
        stan::math::assign(betaR, stan::math::exp(lbetaR));
        current_statement_begin__ = 718;
        stan::math::assign(lAt, ((lA + lka) - log_diff_exp_abs(lka,lalphaR, pstream__)));
        current_statement_begin__ = 719;
        stan::math::assign(lBt, ((lB + lka) - log_diff_exp_abs(lka,lbetaR, pstream__)));
        current_statement_begin__ = 722;
        stan::math::assign(lD, log_diff_exp(lalphaR,lbetaR));
        current_statement_begin__ = 723;
        stan::math::assign(ltemp, log_sum_exp((lB + lD),lbetaR));
        current_statement_begin__ = 724;
        stan::math::assign(lk12, log_diff_exp(log_sum_exp(lalphaR,lbetaR),(log_sum_exp((2 * ltemp),(lalphaR + lbetaR)) - ltemp)));
        current_statement_begin__ = 725;
        stan::math::assign(lk21, log_diff_exp(lalphaR,(lA + lD)));
        current_statement_begin__ = 727;
        stan::math::assign(lad2, (2 * log_diff_exp_abs(lalphaR,lka, pstream__)));
        current_statement_begin__ = 728;
        stan::math::assign(lbd2, (2 * log_diff_exp_abs(lbetaR,lka, pstream__)));
        current_statement_begin__ = 731;
        stan::math::assign(lstateRefOral, get_base1(state0,1,"state0",1));
        current_statement_begin__ = 732;
        stan::model::assign(lstateRef, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    get_base1(state0,2,"state0",1), 
                    "assigning variable lstateRef");
        current_statement_begin__ = 733;
        stan::model::assign(lstateRef, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list()), 
                    get_base1(state0,3,"state0",1), 
                    "assigning variable lstateRef");
        current_statement_begin__ = 734;
        for (int i = 1; i <= N; ++i) {

            current_statement_begin__ = 735;
            stan::model::assign(lstate, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                        (lstateRefOral - (ka * get_base1(Dt,i,"Dt",1))), 
                        "assigning variable lstate");
            current_statement_begin__ = 738;
            stan::model::assign(lstate, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                        (get_base1(lstateRef,1,"lstateRef",1) + log_sum_exp((lA - (alphaR * get_base1(Dt,i,"Dt",1))),(lB - (betaR * get_base1(Dt,i,"Dt",1))))), 
                        "assigning variable lstate");
            current_statement_begin__ = 739;
            stan::model::assign(lstate, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                        (get_base1(lstateRef,2,"lstateRef",1) + log_sum_exp((lB - (alphaR * get_base1(Dt,i,"Dt",1))),(lA - (betaR * get_base1(Dt,i,"Dt",1))))), 
                        "assigning variable lstate");
            current_statement_begin__ = 743;
            if (as_bool(logical_gt(get_base1(Dt,i,"Dt",1),0.0))) {

                current_statement_begin__ = 744;
                stan::model::assign(lstate, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                            stan::model::deep_copy(log_sum_exp(get_base1(lstate,i,2,"lstate",1),(((((get_base1(lstateRef,2,"lstateRef",1) + lD) - lk12) + lA) + lB) + log_diff_exp((-(betaR) * get_base1(Dt,i,"Dt",1)),(-(alphaR) * get_base1(Dt,i,"Dt",1)))))), 
                            "assigning variable lstate");
                current_statement_begin__ = 745;
                stan::model::assign(lstate, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                            stan::model::deep_copy(log_sum_exp(get_base1(lstate,i,3,"lstate",1),(((get_base1(lstateRef,1,"lstateRef",1) + lk12) - lD) + log_diff_exp((-(betaR) * get_base1(Dt,i,"Dt",1)),(-(alphaR) * get_base1(Dt,i,"Dt",1)))))), 
                            "assigning variable lstate");
                current_statement_begin__ = 750;
                stan::model::assign(lstate, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                            stan::model::deep_copy(log_sum_exp(get_base1(lstate,i,2,"lstate",1),(lstateRefOral + log_sum_exp((lAt + log_diff_exp_abs((-(alphaR) * get_base1(Dt,i,"Dt",1)),(-(ka) * get_base1(Dt,i,"Dt",1)), pstream__)),(lBt + log_diff_exp_abs((-(betaR) * get_base1(Dt,i,"Dt",1)),(-(ka) * get_base1(Dt,i,"Dt",1)), pstream__)))))), 
                            "assigning variable lstate");
                current_statement_begin__ = 758;
                stan::model::assign(lstate, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                            stan::model::deep_copy(log_sum_exp(get_base1(lstate,i,3,"lstate",1),((((((lstateRefOral + lk12) + lka) - lD) - lad2) - lbd2) + log_diff_exp(log_sum_exp(log_sum_exp(((lD + log_sum_exp((lalphaR + lbetaR),(2 * lka))) - (ka * get_base1(Dt,i,"Dt",1))),((lalphaR + lbd2) - (alphaR * get_base1(Dt,i,"Dt",1)))),((lka + lad2) - (betaR * get_base1(Dt,i,"Dt",1)))),log_sum_exp(log_sum_exp((((lD + lka) + log_sum_exp(lalphaR,lbetaR)) - (ka * get_base1(Dt,i,"Dt",1))),((lka + lbd2) - (alphaR * get_base1(Dt,i,"Dt",1)))),((lbetaR + lad2) - (betaR * get_base1(Dt,i,"Dt",1)))))))), 
                            "assigning variable lstate");
            }
        }
        current_statement_begin__ = 766;
        return stan::math::promote_scalar<fun_return_scalar_t__>(lstate);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct pk_oral_2cmt_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& state0,
                 const Eigen::Matrix<T1__, Eigen::Dynamic,1>& Dt,
                 const T2__& lka,
                 const T3__& lalphaR,
                 const T4__& lbetaR,
                 const T5__& lA,
                 const T6__& lB, std::ostream* pstream__) const {
        return pk_oral_2cmt(state0, Dt, lka, lalphaR, lbetaR, lA, lB, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic,Eigen::Dynamic>
pk_system(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& lref,
              const Eigen::Matrix<T1__, Eigen::Dynamic,1>& Dt,
              const Eigen::Matrix<T2__, Eigen::Dynamic,1>& theta,
              const std::vector<T3__>& x_r,
              const std::vector<int>& x_i, std::ostream* pstream__);

template <typename T0__, typename T1__, typename T3__, typename T4__, typename T6__, typename T7__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T3__, T4__, typename boost::math::tools::promote_args<T6__, T7__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
pk_system_addl(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& lref,
                   const Eigen::Matrix<T1__, Eigen::Dynamic,1>& Dt,
                   const int& cmt,
                   const T3__& lamt,
                   const T4__& tau,
                   const int& n,
                   const Eigen::Matrix<T6__, Eigen::Dynamic,1>& theta,
                   const std::vector<T7__>& x_r,
                   const std::vector<int>& x_i, std::ostream* pstream__);

template <typename T0__, typename T2__, typename T3__, typename T6__, typename T7__, typename T8__, typename T11__, typename T12__, typename T13__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T2__, T3__, T6__, typename boost::math::tools::promote_args<T7__, T8__, T11__, T12__, typename boost::math::tools::promote_args<T13__>::type>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
pk_model_fast(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& dose_lamt,
                  const std::vector<int>& dose_cmt,
                  const Eigen::Matrix<T2__, Eigen::Dynamic,1>& dose_time,
                  const Eigen::Matrix<T3__, Eigen::Dynamic,1>& dose_tau,
                  const std::vector<int>& dose_addl,
                  const std::vector<int>& dose_next_obs,
                  const Eigen::Matrix<T6__, Eigen::Dynamic,1>& init_lstate,
                  const T7__& init_time,
                  const Eigen::Matrix<T8__, Eigen::Dynamic,1>& obs_time,
                  const std::vector<int>& obs_timeRank,
                  const std::vector<int>& obs_dose_given,
                  const Eigen::Matrix<T11__, Eigen::Dynamic,1>& theta,
                  const Eigen::Matrix<T12__, Eigen::Dynamic,1>& lscale,
                  const std::vector<T13__>& x_r,
                  const std::vector<int>& x_i, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T2__, T3__, T6__, typename boost::math::tools::promote_args<T7__, T8__, T11__, T12__, typename boost::math::tools::promote_args<T13__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 788;
        int D(0);
        (void) D;  // dummy to suppress unused var warning

        stan::math::fill(D, std::numeric_limits<int>::min());
        stan::math::assign(D,num_elements(dose_lamt));
        current_statement_begin__ = 789;
        int O(0);
        (void) O;  // dummy to suppress unused var warning

        stan::math::fill(O, std::numeric_limits<int>::min());
        stan::math::assign(O,num_elements(obs_time));
        current_statement_begin__ = 790;
        int d(0);
        (void) d;  // dummy to suppress unused var warning

        stan::math::fill(d, std::numeric_limits<int>::min());
        stan::math::assign(d,0);
        current_statement_begin__ = 791;
        int o(0);
        (void) o;  // dummy to suppress unused var warning

        stan::math::fill(o, std::numeric_limits<int>::min());
        stan::math::assign(o,1);
        current_statement_begin__ = 792;
        int active_addl(0);
        (void) active_addl;  // dummy to suppress unused var warning

        stan::math::fill(active_addl, std::numeric_limits<int>::min());
        stan::math::assign(active_addl,0);
        current_statement_begin__ = 793;
        int init_ref(0);
        (void) init_ref;  // dummy to suppress unused var warning

        stan::math::fill(init_ref, std::numeric_limits<int>::min());
        stan::math::assign(init_ref,1);
        current_statement_begin__ = 794;
        validate_non_negative_index("lstate_ref", "num_elements(init_lstate)", num_elements(init_lstate));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  lstate_ref(static_cast<Eigen::VectorXd::Index>(num_elements(init_lstate)));
        (void) lstate_ref;  // dummy to suppress unused var warning

        stan::math::initialize(lstate_ref, DUMMY_VAR__);
        stan::math::fill(lstate_ref,DUMMY_VAR__);
        stan::math::assign(lstate_ref,init_lstate);
        current_statement_begin__ = 795;
        validate_non_negative_index("lstate", "num_elements(obs_time)", num_elements(obs_time));
        validate_non_negative_index("lstate", "num_elements(init_lstate)", num_elements(init_lstate));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  lstate(static_cast<Eigen::VectorXd::Index>(num_elements(obs_time)),static_cast<Eigen::VectorXd::Index>(num_elements(init_lstate)));
        (void) lstate;  // dummy to suppress unused var warning

        stan::math::initialize(lstate, DUMMY_VAR__);
        stan::math::fill(lstate,DUMMY_VAR__);


        current_statement_begin__ = 798;
        while (as_bool((primitive_value(logical_lt(d,D)) && primitive_value(logical_lt(get_base1(dose_time,(d + 1),"dose_time",1),init_time))))) {

            current_statement_begin__ = 798;
            stan::math::assign(d, stan::model::deep_copy((d + 1)));
        }
        current_statement_begin__ = 800;
        while (as_bool(logical_lte(o,O))) {

            current_statement_begin__ = 803;
            while (as_bool(logical_neq(d,get_base1(obs_timeRank,o,"obs_timeRank",1)))) {
                {
                current_statement_begin__ = 804;
                int nd(0);
                (void) nd;  // dummy to suppress unused var warning

                stan::math::fill(nd, std::numeric_limits<int>::min());


                current_statement_begin__ = 807;
                stan::math::assign(nd, (d + 1));
                current_statement_begin__ = 808;
                if (as_bool(init_ref)) {

                    current_statement_begin__ = 809;
                    stan::math::assign(lstate_ref, stan::model::deep_copy(to_vector(get_base1(pk_system(lstate_ref,rep_vector((get_base1(dose_time,nd,"dose_time",1) - init_time),1),theta,x_r,x_i, pstream__),1,"pk_system(lstate_ref,rep_vector((get_base1(dose_time,nd,\"dose_time\",1) - init_time),1),theta,x_r,x_i, pstream__)",1))));
                } else if (as_bool(active_addl)) {

                    current_statement_begin__ = 815;
                    stan::math::assign(lstate_ref, stan::model::deep_copy(to_vector(get_base1(pk_system_addl(lstate_ref,rep_vector((get_base1(dose_time,nd,"dose_time",1) - get_base1(dose_time,d,"dose_time",1)),1),get_base1(dose_cmt,d,"dose_cmt",1),get_base1(dose_lamt,d,"dose_lamt",1),get_base1(dose_tau,d,"dose_tau",1),get_base1(dose_addl,d,"dose_addl",1),theta,x_r,x_i, pstream__),1,"pk_system_addl(lstate_ref,rep_vector((get_base1(dose_time,nd,\"dose_time\",1) - get_base1(dose_time,d,\"dose_time\",1)),1),get_base1(dose_cmt,d,\"dose_cmt\",1),get_base1(dose_lamt,d,\"dose_lamt\",1),get_base1(dose_tau,d,\"dose_tau\",1),get_base1(dose_addl,d,\"dose_addl\",1),theta,x_r,x_i, pstream__)",1))));
                } else {

                    current_statement_begin__ = 818;
                    stan::math::assign(lstate_ref, stan::model::deep_copy(to_vector(get_base1(pk_system(lstate_ref,rep_vector((get_base1(dose_time,nd,"dose_time",1) - get_base1(dose_time,d,"dose_time",1)),1),theta,x_r,x_i, pstream__),1,"pk_system(lstate_ref,rep_vector((get_base1(dose_time,nd,\"dose_time\",1) - get_base1(dose_time,d,\"dose_time\",1)),1),theta,x_r,x_i, pstream__)",1))));
                }
                current_statement_begin__ = 826;
                stan::math::assign(active_addl, logical_gt(get_base1(dose_addl,nd,"dose_addl",1),0));
                current_statement_begin__ = 827;
                if (as_bool(logical_negation(active_addl))) {

                    current_statement_begin__ = 828;
                    stan::model::assign(lstate_ref, 
                                stan::model::cons_list(stan::model::index_uni(get_base1(dose_cmt,nd,"dose_cmt",1)), stan::model::nil_index_list()), 
                                stan::model::deep_copy(log_sum_exp(get_base1(lstate_ref,get_base1(dose_cmt,nd,"dose_cmt",1),"lstate_ref",1),get_base1(dose_lamt,nd,"dose_lamt",1))), 
                                "assigning variable lstate_ref");
                }
                current_statement_begin__ = 830;
                stan::math::assign(d, nd);
                current_statement_begin__ = 833;
                stan::math::assign(init_ref, 0);
                }
            }
            current_statement_begin__ = 837;
            if (as_bool(init_ref)) {

                current_statement_begin__ = 838;
                stan::model::assign(lstate, 
                            stan::model::cons_list(stan::model::index_uni(o), stan::model::nil_index_list()), 
                            get_base1(pk_system(lstate_ref,subtract(segment(obs_time,o,1),init_time),theta,x_r,x_i, pstream__),1,"pk_system(lstate_ref,subtract(segment(obs_time,o,1),init_time),theta,x_r,x_i, pstream__)",1), 
                            "assigning variable lstate");
                current_statement_begin__ = 840;
                stan::math::assign(o, stan::model::deep_copy((o + 1)));
            } else if (as_bool(active_addl)) {
                {
                current_statement_begin__ = 842;
                int ndose(0);
                (void) ndose;  // dummy to suppress unused var warning

                stan::math::fill(ndose, std::numeric_limits<int>::min());
                current_statement_begin__ = 843;
                int event_free(0);
                (void) event_free;  // dummy to suppress unused var warning

                stan::math::fill(event_free, std::numeric_limits<int>::min());


                current_statement_begin__ = 847;
                stan::math::assign(ndose, get_base1(obs_dose_given,o,"obs_dose_given",1));
                current_statement_begin__ = 850;
                stan::math::assign(event_free, 0);
                current_statement_begin__ = 851;
                while (as_bool((primitive_value(logical_lt((o + event_free),O)) && primitive_value(logical_eq(get_base1(obs_dose_given,((o + event_free) + 1),"obs_dose_given",1),ndose))))) {
                    current_statement_begin__ = 852;
                    stan::math::assign(event_free, stan::model::deep_copy((event_free + 1)));
                }
                current_statement_begin__ = 854;
                stan::model::assign(lstate, 
                            stan::model::cons_list(stan::model::index_min_max(o, (o + event_free)), stan::model::nil_index_list()), 
                            pk_system_addl(lstate_ref,subtract(segment(obs_time,o,(event_free + 1)),get_base1(dose_time,d,"dose_time",1)),get_base1(dose_cmt,d,"dose_cmt",1),get_base1(dose_lamt,d,"dose_lamt",1),get_base1(dose_tau,d,"dose_tau",1),ndose,theta,x_r,x_i, pstream__), 
                            "assigning variable lstate");
                current_statement_begin__ = 856;
                stan::math::assign(o, stan::model::deep_copy(((o + event_free) + 1)));
                }
            } else {
                {
                current_statement_begin__ = 860;
                int event_free(0);
                (void) event_free;  // dummy to suppress unused var warning

                stan::math::fill(event_free, std::numeric_limits<int>::min());


                current_statement_begin__ = 861;
                stan::math::assign(event_free, get_base1(dose_next_obs,d,"dose_next_obs",1));
                current_statement_begin__ = 862;
                stan::model::assign(lstate, 
                            stan::model::cons_list(stan::model::index_min_max(o, ((o + event_free) - 1)), stan::model::nil_index_list()), 
                            pk_system(lstate_ref,subtract(segment(obs_time,o,event_free),get_base1(dose_time,d,"dose_time",1)),theta,x_r,x_i, pstream__), 
                            "assigning variable lstate");
                current_statement_begin__ = 864;
                stan::math::assign(o, stan::model::deep_copy((o + event_free)));
                }
            }
        }
        current_statement_begin__ = 867;
        return stan::math::promote_scalar<fun_return_scalar_t__>(subtract(lstate,rep_matrix(to_row_vector(lscale),O)));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct pk_model_fast_functor__ {
    template <typename T0__, typename T2__, typename T3__, typename T6__, typename T7__, typename T8__, typename T11__, typename T12__, typename T13__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T2__, T3__, T6__, typename boost::math::tools::promote_args<T7__, T8__, T11__, T12__, typename boost::math::tools::promote_args<T13__>::type>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& dose_lamt,
                  const std::vector<int>& dose_cmt,
                  const Eigen::Matrix<T2__, Eigen::Dynamic,1>& dose_time,
                  const Eigen::Matrix<T3__, Eigen::Dynamic,1>& dose_tau,
                  const std::vector<int>& dose_addl,
                  const std::vector<int>& dose_next_obs,
                  const Eigen::Matrix<T6__, Eigen::Dynamic,1>& init_lstate,
                  const T7__& init_time,
                  const Eigen::Matrix<T8__, Eigen::Dynamic,1>& obs_time,
                  const std::vector<int>& obs_timeRank,
                  const std::vector<int>& obs_dose_given,
                  const Eigen::Matrix<T11__, Eigen::Dynamic,1>& theta,
                  const Eigen::Matrix<T12__, Eigen::Dynamic,1>& lscale,
                  const std::vector<T13__>& x_r,
                  const std::vector<int>& x_i, std::ostream* pstream__) const {
        return pk_model_fast(dose_lamt, dose_cmt, dose_time, dose_tau, dose_addl, dose_next_obs, init_lstate, init_time, obs_time, obs_timeRank, obs_dose_given, theta, lscale, x_r, x_i, pstream__);
    }
};

template <typename T0__, typename T2__, typename T3__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, typename T10__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T2__, T3__, T5__, typename boost::math::tools::promote_args<T6__, T7__, T8__, T9__, typename boost::math::tools::promote_args<T10__>::type>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
pk_model(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& dose_lamt,
             const std::vector<int>& dose_cmt,
             const Eigen::Matrix<T2__, Eigen::Dynamic,1>& dose_time,
             const Eigen::Matrix<T3__, Eigen::Dynamic,1>& dose_tau,
             const std::vector<int>& dose_addl,
             const Eigen::Matrix<T5__, Eigen::Dynamic,1>& init_lstate,
             const T6__& init_time,
             const Eigen::Matrix<T7__, Eigen::Dynamic,1>& obs_time,
             const Eigen::Matrix<T8__, Eigen::Dynamic,1>& theta,
             const Eigen::Matrix<T9__, Eigen::Dynamic,1>& lscale,
             const std::vector<T10__>& x_r,
             const std::vector<int>& x_i, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T2__, T3__, T5__, typename boost::math::tools::promote_args<T6__, T7__, T8__, T9__, typename boost::math::tools::promote_args<T10__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 876;
        validate_non_negative_index("obs_timeRank", "num_elements(obs_time)", num_elements(obs_time));
        vector<int> obs_timeRank(num_elements(obs_time), 0);
        stan::math::fill(obs_timeRank, std::numeric_limits<int>::min());
        stan::math::assign(obs_timeRank,find_interval(obs_time,dose_time, pstream__));


        current_statement_begin__ = 877;
        check_addl_dosing(dose_time,dose_tau,dose_addl, pstream__);
        current_statement_begin__ = 878;
        if (as_bool(logical_gt(init_time,get_base1(dose_time,1,"dose_time",1)))) {
            current_statement_begin__ = 879;
            std::stringstream errmsg_stream__;
            errmsg_stream__ << "Initial time must be at or before first dose!";
            throw std::domain_error(errmsg_stream__.str());
        }
        current_statement_begin__ = 880;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pk_model_fast(dose_lamt,dose_cmt,dose_time,dose_tau,dose_addl,count_obs_event_free(obs_timeRank,size(dose_cmt), pstream__),init_lstate,init_time,obs_time,obs_timeRank,count_dose_given(obs_time,dose_time,dose_tau,dose_addl, pstream__),theta,lscale,x_r,x_i, pstream__));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct pk_model_functor__ {
    template <typename T0__, typename T2__, typename T3__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, typename T10__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T2__, T3__, T5__, typename boost::math::tools::promote_args<T6__, T7__, T8__, T9__, typename boost::math::tools::promote_args<T10__>::type>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& dose_lamt,
             const std::vector<int>& dose_cmt,
             const Eigen::Matrix<T2__, Eigen::Dynamic,1>& dose_time,
             const Eigen::Matrix<T3__, Eigen::Dynamic,1>& dose_tau,
             const std::vector<int>& dose_addl,
             const Eigen::Matrix<T5__, Eigen::Dynamic,1>& init_lstate,
             const T6__& init_time,
             const Eigen::Matrix<T7__, Eigen::Dynamic,1>& obs_time,
             const Eigen::Matrix<T8__, Eigen::Dynamic,1>& theta,
             const Eigen::Matrix<T9__, Eigen::Dynamic,1>& lscale,
             const std::vector<T10__>& x_r,
             const std::vector<int>& x_i, std::ostream* pstream__) const {
        return pk_model(dose_lamt, dose_cmt, dose_time, dose_tau, dose_addl, init_lstate, init_time, obs_time, theta, lscale, x_r, x_i, pstream__);
    }
};

template <typename T1__, typename T3__, typename T4__, typename T7__, typename T8__, typename T10__, typename T13__, typename T14__, typename T15__>
Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T3__, T4__, T7__, typename boost::math::tools::promote_args<T8__, T10__, T13__, T14__, typename boost::math::tools::promote_args<T15__>::type>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
evaluate_model_fast(const std::vector<int>& dose_M,
                        const Eigen::Matrix<T1__, Eigen::Dynamic,1>& dose_lamt,
                        const std::vector<int>& dose_cmt,
                        const Eigen::Matrix<T3__, Eigen::Dynamic,1>& dose_time,
                        const Eigen::Matrix<T4__, Eigen::Dynamic,1>& dose_tau,
                        const std::vector<int>& dose_addl,
                        const std::vector<int>& dose_next_obs,
                        const Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic>& init_lstate,
                        const Eigen::Matrix<T8__, Eigen::Dynamic,1>& init_time,
                        const std::vector<int>& obs_M,
                        const Eigen::Matrix<T10__, Eigen::Dynamic,1>& obs_time,
                        const std::vector<int>& obs_timeRank,
                        const std::vector<int>& obs_dose_given,
                        const Eigen::Matrix<T13__, Eigen::Dynamic,Eigen::Dynamic>& theta,
                        const Eigen::Matrix<T14__, Eigen::Dynamic,Eigen::Dynamic>& lscale,
                        const std::vector<T15__>& x_r,
                        const std::vector<int>& x_i, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T3__, T4__, T7__, typename boost::math::tools::promote_args<T8__, T10__, T13__, T14__, typename boost::math::tools::promote_args<T15__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 895;
        validate_non_negative_index("lstate", "num_elements(obs_time)", num_elements(obs_time));
        validate_non_negative_index("lstate", "cols(init_lstate)", cols(init_lstate));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  lstate(static_cast<Eigen::VectorXd::Index>(num_elements(obs_time)),static_cast<Eigen::VectorXd::Index>(cols(init_lstate)));
        (void) lstate;  // dummy to suppress unused var warning

        stan::math::initialize(lstate, DUMMY_VAR__);
        stan::math::fill(lstate,DUMMY_VAR__);
        current_statement_begin__ = 896;
        int J(0);
        (void) J;  // dummy to suppress unused var warning

        stan::math::fill(J, std::numeric_limits<int>::min());
        stan::math::assign(J,num_elements(dose_M));
        current_statement_begin__ = 897;
        int d(0);
        (void) d;  // dummy to suppress unused var warning

        stan::math::fill(d, std::numeric_limits<int>::min());
        stan::math::assign(d,1);
        current_statement_begin__ = 898;
        int o(0);
        (void) o;  // dummy to suppress unused var warning

        stan::math::fill(o, std::numeric_limits<int>::min());
        stan::math::assign(o,1);
        current_statement_begin__ = 899;
        int S(0);
        (void) S;  // dummy to suppress unused var warning

        stan::math::fill(S, std::numeric_limits<int>::min());
        stan::math::assign(S,cols(lscale));


        current_statement_begin__ = 901;
        for (int j = 1; j <= J; ++j) {
            {
            current_statement_begin__ = 902;
            validate_non_negative_index("lstate_j", "get_base1(obs_M,j,\"obs_M\",1)", get_base1(obs_M,j,"obs_M",1));
            validate_non_negative_index("lstate_j", "S", S);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  lstate_j(static_cast<Eigen::VectorXd::Index>(get_base1(obs_M,j,"obs_M",1)),static_cast<Eigen::VectorXd::Index>(S));
            (void) lstate_j;  // dummy to suppress unused var warning

            stan::math::initialize(lstate_j, DUMMY_VAR__);
            stan::math::fill(lstate_j,DUMMY_VAR__);
            current_statement_begin__ = 903;
            int d_m(0);
            (void) d_m;  // dummy to suppress unused var warning

            stan::math::fill(d_m, std::numeric_limits<int>::min());
            stan::math::assign(d_m,get_base1(dose_M,j,"dose_M",1));
            current_statement_begin__ = 904;
            int o_m(0);
            (void) o_m;  // dummy to suppress unused var warning

            stan::math::fill(o_m, std::numeric_limits<int>::min());
            stan::math::assign(o_m,get_base1(obs_M,j,"obs_M",1));


            current_statement_begin__ = 906;
            stan::math::assign(lstate_j, pk_model_fast(segment(dose_lamt,d,d_m),segment(dose_cmt,d,d_m),segment(dose_time,d,d_m),segment(dose_tau,d,d_m),segment(dose_addl,d,d_m),segment(dose_next_obs,d,d_m),to_vector(get_base1(init_lstate,j,"init_lstate",1)),get_base1(init_time,j,"init_time",1),segment(obs_time,o,o_m),segment(obs_timeRank,o,o_m),segment(obs_dose_given,o,o_m),to_vector(get_base1(theta,j,"theta",1)),to_vector(get_base1(lscale,j,"lscale",1)),x_r,x_i, pstream__));
            current_statement_begin__ = 913;
            for (int i = 1; i <= o_m; ++i) {
                current_statement_begin__ = 914;
                stan::model::assign(lstate, 
                            stan::model::cons_list(stan::model::index_uni(((i + o) - 1)), stan::model::nil_index_list()), 
                            get_base1(lstate_j,i,"lstate_j",1), 
                            "assigning variable lstate");
            }
            current_statement_begin__ = 916;
            stan::math::assign(d, stan::model::deep_copy((d + d_m)));
            current_statement_begin__ = 917;
            stan::math::assign(o, stan::model::deep_copy((o + o_m)));
            }
        }
        current_statement_begin__ = 919;
        return stan::math::promote_scalar<fun_return_scalar_t__>(lstate);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct evaluate_model_fast_functor__ {
    template <typename T1__, typename T3__, typename T4__, typename T7__, typename T8__, typename T10__, typename T13__, typename T14__, typename T15__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T3__, T4__, T7__, typename boost::math::tools::promote_args<T8__, T10__, T13__, T14__, typename boost::math::tools::promote_args<T15__>::type>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const std::vector<int>& dose_M,
                        const Eigen::Matrix<T1__, Eigen::Dynamic,1>& dose_lamt,
                        const std::vector<int>& dose_cmt,
                        const Eigen::Matrix<T3__, Eigen::Dynamic,1>& dose_time,
                        const Eigen::Matrix<T4__, Eigen::Dynamic,1>& dose_tau,
                        const std::vector<int>& dose_addl,
                        const std::vector<int>& dose_next_obs,
                        const Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic>& init_lstate,
                        const Eigen::Matrix<T8__, Eigen::Dynamic,1>& init_time,
                        const std::vector<int>& obs_M,
                        const Eigen::Matrix<T10__, Eigen::Dynamic,1>& obs_time,
                        const std::vector<int>& obs_timeRank,
                        const std::vector<int>& obs_dose_given,
                        const Eigen::Matrix<T13__, Eigen::Dynamic,Eigen::Dynamic>& theta,
                        const Eigen::Matrix<T14__, Eigen::Dynamic,Eigen::Dynamic>& lscale,
                        const std::vector<T15__>& x_r,
                        const std::vector<int>& x_i, std::ostream* pstream__) const {
        return evaluate_model_fast(dose_M, dose_lamt, dose_cmt, dose_time, dose_tau, dose_addl, dose_next_obs, init_lstate, init_time, obs_M, obs_time, obs_timeRank, obs_dose_given, theta, lscale, x_r, x_i, pstream__);
    }
};

template <typename T1__, typename T3__, typename T4__, typename T7__, typename T8__, typename T10__, typename T14__, typename T15__, typename T16__>
Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T3__, T4__, T7__, typename boost::math::tools::promote_args<T8__, T10__, T14__, T15__, typename boost::math::tools::promote_args<T16__>::type>::type>::type, Eigen::Dynamic,1>
evaluate_model_fast_cmt(const std::vector<int>& dose_M,
                            const Eigen::Matrix<T1__, Eigen::Dynamic,1>& dose_lamt,
                            const std::vector<int>& dose_cmt,
                            const Eigen::Matrix<T3__, Eigen::Dynamic,1>& dose_time,
                            const Eigen::Matrix<T4__, Eigen::Dynamic,1>& dose_tau,
                            const std::vector<int>& dose_addl,
                            const std::vector<int>& dose_next_obs,
                            const Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic>& init_lstate,
                            const Eigen::Matrix<T8__, Eigen::Dynamic,1>& init_time,
                            const std::vector<int>& obs_M,
                            const Eigen::Matrix<T10__, Eigen::Dynamic,1>& obs_time,
                            const std::vector<int>& obs_timeRank,
                            const std::vector<int>& obs_dose_given,
                            const std::vector<int>& obs_cmt,
                            const Eigen::Matrix<T14__, Eigen::Dynamic,Eigen::Dynamic>& theta,
                            const Eigen::Matrix<T15__, Eigen::Dynamic,Eigen::Dynamic>& lscale,
                            const std::vector<T16__>& x_r,
                            const std::vector<int>& x_i, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T3__, T4__, T7__, typename boost::math::tools::promote_args<T8__, T10__, T14__, T15__, typename boost::math::tools::promote_args<T16__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 929;
        validate_non_negative_index("lstate", "num_elements(obs_time)", num_elements(obs_time));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  lstate(static_cast<Eigen::VectorXd::Index>(num_elements(obs_time)));
        (void) lstate;  // dummy to suppress unused var warning

        stan::math::initialize(lstate, DUMMY_VAR__);
        stan::math::fill(lstate,DUMMY_VAR__);
        current_statement_begin__ = 930;
        int J(0);
        (void) J;  // dummy to suppress unused var warning

        stan::math::fill(J, std::numeric_limits<int>::min());
        stan::math::assign(J,num_elements(dose_M));
        current_statement_begin__ = 931;
        int d(0);
        (void) d;  // dummy to suppress unused var warning

        stan::math::fill(d, std::numeric_limits<int>::min());
        stan::math::assign(d,1);
        current_statement_begin__ = 932;
        int o(0);
        (void) o;  // dummy to suppress unused var warning

        stan::math::fill(o, std::numeric_limits<int>::min());
        stan::math::assign(o,1);
        current_statement_begin__ = 933;
        int S(0);
        (void) S;  // dummy to suppress unused var warning

        stan::math::fill(S, std::numeric_limits<int>::min());
        stan::math::assign(S,cols(lscale));


        current_statement_begin__ = 935;
        for (int j = 1; j <= J; ++j) {
            {
            current_statement_begin__ = 936;
            validate_non_negative_index("lstate_j", "get_base1(obs_M,j,\"obs_M\",1)", get_base1(obs_M,j,"obs_M",1));
            validate_non_negative_index("lstate_j", "S", S);
            Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  lstate_j(static_cast<Eigen::VectorXd::Index>(get_base1(obs_M,j,"obs_M",1)),static_cast<Eigen::VectorXd::Index>(S));
            (void) lstate_j;  // dummy to suppress unused var warning

            stan::math::initialize(lstate_j, DUMMY_VAR__);
            stan::math::fill(lstate_j,DUMMY_VAR__);
            current_statement_begin__ = 937;
            int d_m(0);
            (void) d_m;  // dummy to suppress unused var warning

            stan::math::fill(d_m, std::numeric_limits<int>::min());
            stan::math::assign(d_m,get_base1(dose_M,j,"dose_M",1));
            current_statement_begin__ = 938;
            int o_m(0);
            (void) o_m;  // dummy to suppress unused var warning

            stan::math::fill(o_m, std::numeric_limits<int>::min());
            stan::math::assign(o_m,get_base1(obs_M,j,"obs_M",1));


            current_statement_begin__ = 940;
            stan::math::assign(lstate_j, pk_model_fast(segment(dose_lamt,d,d_m),segment(dose_cmt,d,d_m),segment(dose_time,d,d_m),segment(dose_tau,d,d_m),segment(dose_addl,d,d_m),segment(dose_next_obs,d,d_m),to_vector(get_base1(init_lstate,j,"init_lstate",1)),get_base1(init_time,j,"init_time",1),segment(obs_time,o,o_m),segment(obs_timeRank,o,o_m),segment(obs_dose_given,o,o_m),to_vector(get_base1(theta,j,"theta",1)),to_vector(get_base1(lscale,j,"lscale",1)),x_r,x_i, pstream__));
            current_statement_begin__ = 947;
            for (int i = 1; i <= o_m; ++i) {
                current_statement_begin__ = 948;
                stan::model::assign(lstate, 
                            stan::model::cons_list(stan::model::index_uni(((i + o) - 1)), stan::model::nil_index_list()), 
                            get_base1(lstate_j,i,get_base1(obs_cmt,((i + o) - 1),"obs_cmt",1),"lstate_j",1), 
                            "assigning variable lstate");
            }
            current_statement_begin__ = 950;
            stan::math::assign(d, stan::model::deep_copy((d + d_m)));
            current_statement_begin__ = 951;
            stan::math::assign(o, stan::model::deep_copy((o + o_m)));
            }
        }
        current_statement_begin__ = 953;
        return stan::math::promote_scalar<fun_return_scalar_t__>(lstate);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct evaluate_model_fast_cmt_functor__ {
    template <typename T1__, typename T3__, typename T4__, typename T7__, typename T8__, typename T10__, typename T14__, typename T15__, typename T16__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T3__, T4__, T7__, typename boost::math::tools::promote_args<T8__, T10__, T14__, T15__, typename boost::math::tools::promote_args<T16__>::type>::type>::type, Eigen::Dynamic,1>
    operator()(const std::vector<int>& dose_M,
                            const Eigen::Matrix<T1__, Eigen::Dynamic,1>& dose_lamt,
                            const std::vector<int>& dose_cmt,
                            const Eigen::Matrix<T3__, Eigen::Dynamic,1>& dose_time,
                            const Eigen::Matrix<T4__, Eigen::Dynamic,1>& dose_tau,
                            const std::vector<int>& dose_addl,
                            const std::vector<int>& dose_next_obs,
                            const Eigen::Matrix<T7__, Eigen::Dynamic,Eigen::Dynamic>& init_lstate,
                            const Eigen::Matrix<T8__, Eigen::Dynamic,1>& init_time,
                            const std::vector<int>& obs_M,
                            const Eigen::Matrix<T10__, Eigen::Dynamic,1>& obs_time,
                            const std::vector<int>& obs_timeRank,
                            const std::vector<int>& obs_dose_given,
                            const std::vector<int>& obs_cmt,
                            const Eigen::Matrix<T14__, Eigen::Dynamic,Eigen::Dynamic>& theta,
                            const Eigen::Matrix<T15__, Eigen::Dynamic,Eigen::Dynamic>& lscale,
                            const std::vector<T16__>& x_r,
                            const std::vector<int>& x_i, std::ostream* pstream__) const {
        return evaluate_model_fast_cmt(dose_M, dose_lamt, dose_cmt, dose_time, dose_tau, dose_addl, dose_next_obs, init_lstate, init_time, obs_M, obs_time, obs_timeRank, obs_dose_given, obs_cmt, theta, lscale, x_r, x_i, pstream__);
    }
};

template <typename T1__, typename T3__, typename T4__, typename T6__, typename T7__, typename T9__, typename T10__, typename T11__, typename T12__>
Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T3__, T4__, T6__, typename boost::math::tools::promote_args<T7__, T9__, T10__, T11__, typename boost::math::tools::promote_args<T12__>::type>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
evaluate_model(const std::vector<int>& dose_M,
                   const Eigen::Matrix<T1__, Eigen::Dynamic,1>& dose_lamt,
                   const std::vector<int>& dose_cmt,
                   const Eigen::Matrix<T3__, Eigen::Dynamic,1>& dose_time,
                   const Eigen::Matrix<T4__, Eigen::Dynamic,1>& dose_tau,
                   const std::vector<int>& dose_addl,
                   const Eigen::Matrix<T6__, Eigen::Dynamic,Eigen::Dynamic>& init_lstate,
                   const Eigen::Matrix<T7__, Eigen::Dynamic,1>& init_time,
                   const std::vector<int>& obs_M,
                   const Eigen::Matrix<T9__, Eigen::Dynamic,1>& obs_time,
                   const Eigen::Matrix<T10__, Eigen::Dynamic,Eigen::Dynamic>& theta,
                   const Eigen::Matrix<T11__, Eigen::Dynamic,Eigen::Dynamic>& lscale,
                   const std::vector<T12__>& x_r,
                   const std::vector<int>& x_i, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T3__, T4__, T6__, typename boost::math::tools::promote_args<T7__, T9__, T10__, T11__, typename boost::math::tools::promote_args<T12__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 962;
        validate_non_negative_index("obs_timeRank", "num_elements(obs_time)", num_elements(obs_time));
        vector<int> obs_timeRank(num_elements(obs_time), 0);
        stan::math::fill(obs_timeRank, std::numeric_limits<int>::min());
        stan::math::assign(obs_timeRank,find_interval_blocked(obs_M,obs_time,dose_M,dose_time, pstream__));


        current_statement_begin__ = 963;
        check_addl_dosing_blocked(dose_M,dose_time,dose_tau,dose_addl, pstream__);
        current_statement_begin__ = 964;
        return stan::math::promote_scalar<fun_return_scalar_t__>(evaluate_model_fast(dose_M,dose_lamt,dose_cmt,dose_time,dose_tau,dose_addl,count_obs_event_free_blocked(obs_M,obs_timeRank,dose_M, pstream__),init_lstate,init_time,obs_M,obs_time,obs_timeRank,count_dose_given_blocked(obs_M,obs_time,dose_M,dose_time,dose_tau,dose_addl, pstream__),theta,lscale,x_r,x_i, pstream__));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct evaluate_model_functor__ {
    template <typename T1__, typename T3__, typename T4__, typename T6__, typename T7__, typename T9__, typename T10__, typename T11__, typename T12__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T3__, T4__, T6__, typename boost::math::tools::promote_args<T7__, T9__, T10__, T11__, typename boost::math::tools::promote_args<T12__>::type>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const std::vector<int>& dose_M,
                   const Eigen::Matrix<T1__, Eigen::Dynamic,1>& dose_lamt,
                   const std::vector<int>& dose_cmt,
                   const Eigen::Matrix<T3__, Eigen::Dynamic,1>& dose_time,
                   const Eigen::Matrix<T4__, Eigen::Dynamic,1>& dose_tau,
                   const std::vector<int>& dose_addl,
                   const Eigen::Matrix<T6__, Eigen::Dynamic,Eigen::Dynamic>& init_lstate,
                   const Eigen::Matrix<T7__, Eigen::Dynamic,1>& init_time,
                   const std::vector<int>& obs_M,
                   const Eigen::Matrix<T9__, Eigen::Dynamic,1>& obs_time,
                   const Eigen::Matrix<T10__, Eigen::Dynamic,Eigen::Dynamic>& theta,
                   const Eigen::Matrix<T11__, Eigen::Dynamic,Eigen::Dynamic>& lscale,
                   const std::vector<T12__>& x_r,
                   const std::vector<int>& x_i, std::ostream* pstream__) const {
        return evaluate_model(dose_M, dose_lamt, dose_cmt, dose_time, dose_tau, dose_addl, init_lstate, init_time, obs_M, obs_time, theta, lscale, x_r, x_i, pstream__);
    }
};

template <typename T1__, typename T4__, typename T5__, typename T8__, typename T9__, typename T10__, typename T11__, typename T12__>
Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T4__, T5__, T8__, typename boost::math::tools::promote_args<T9__, T10__, T11__, T12__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
evaluate_model_nm(const std::vector<int>& id,
                      const Eigen::Matrix<T1__, Eigen::Dynamic,1>& time,
                      const std::vector<int>& cmt,
                      const std::vector<int>& evid,
                      const Eigen::Matrix<T4__, Eigen::Dynamic,1>& amt,
                      const Eigen::Matrix<T5__, Eigen::Dynamic,1>& tau,
                      const std::vector<int>& addl,
                      const std::vector<int>& mdv,
                      const Eigen::Matrix<T8__, Eigen::Dynamic,Eigen::Dynamic>& init_lstate,
                      const Eigen::Matrix<T9__, Eigen::Dynamic,1>& init_time,
                      const Eigen::Matrix<T10__, Eigen::Dynamic,Eigen::Dynamic>& theta,
                      const Eigen::Matrix<T11__, Eigen::Dynamic,Eigen::Dynamic>& lscale,
                      const std::vector<T12__>& x_r,
                      const std::vector<int>& x_i, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T4__, T5__, T8__, typename boost::math::tools::promote_args<T9__, T10__, T11__, T12__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 977;
        validate_non_negative_index("dose_ind", "count_elem(evid,1, pstream__)", count_elem(evid,1, pstream__));
        vector<int> dose_ind(count_elem(evid,1, pstream__), 0);
        stan::math::fill(dose_ind, std::numeric_limits<int>::min());
        stan::math::assign(dose_ind,which_elem(evid,1, pstream__));


        current_statement_begin__ = 979;
        return stan::math::promote_scalar<fun_return_scalar_t__>(evaluate_model(rle_int(stan::model::rvalue(id, stan::model::cons_list(stan::model::index_multi(dose_ind), stan::model::nil_index_list()), "id"), pstream__),stan::math::log(stan::model::rvalue(amt, stan::model::cons_list(stan::model::index_multi(dose_ind), stan::model::nil_index_list()), "amt")),stan::model::rvalue(cmt, stan::model::cons_list(stan::model::index_multi(dose_ind), stan::model::nil_index_list()), "cmt"),stan::model::rvalue(time, stan::model::cons_list(stan::model::index_multi(dose_ind), stan::model::nil_index_list()), "time"),stan::model::rvalue(tau, stan::model::cons_list(stan::model::index_multi(dose_ind), stan::model::nil_index_list()), "tau"),stan::model::rvalue(addl, stan::model::cons_list(stan::model::index_multi(dose_ind), stan::model::nil_index_list()), "addl"),init_lstate,init_time,rle_int(id, pstream__),time,theta,lscale,x_r,x_i, pstream__));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct evaluate_model_nm_functor__ {
    template <typename T1__, typename T4__, typename T5__, typename T8__, typename T9__, typename T10__, typename T11__, typename T12__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T4__, T5__, T8__, typename boost::math::tools::promote_args<T9__, T10__, T11__, T12__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const std::vector<int>& id,
                      const Eigen::Matrix<T1__, Eigen::Dynamic,1>& time,
                      const std::vector<int>& cmt,
                      const std::vector<int>& evid,
                      const Eigen::Matrix<T4__, Eigen::Dynamic,1>& amt,
                      const Eigen::Matrix<T5__, Eigen::Dynamic,1>& tau,
                      const std::vector<int>& addl,
                      const std::vector<int>& mdv,
                      const Eigen::Matrix<T8__, Eigen::Dynamic,Eigen::Dynamic>& init_lstate,
                      const Eigen::Matrix<T9__, Eigen::Dynamic,1>& init_time,
                      const Eigen::Matrix<T10__, Eigen::Dynamic,Eigen::Dynamic>& theta,
                      const Eigen::Matrix<T11__, Eigen::Dynamic,Eigen::Dynamic>& lscale,
                      const std::vector<T12__>& x_r,
                      const std::vector<int>& x_i, std::ostream* pstream__) const {
        return evaluate_model_nm(id, time, cmt, evid, amt, tau, addl, mdv, init_lstate, init_time, theta, lscale, x_r, x_i, pstream__);
    }
};

template <typename T1__, typename T4__, typename T5__, typename T8__, typename T9__, typename T10__, typename T11__, typename T12__>
Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T4__, T5__, T8__, typename boost::math::tools::promote_args<T9__, T10__, T11__, T12__>::type>::type, Eigen::Dynamic,1>
evaluate_model_nm_cmt(const std::vector<int>& id,
                          const Eigen::Matrix<T1__, Eigen::Dynamic,1>& time,
                          const std::vector<int>& cmt,
                          const std::vector<int>& evid,
                          const Eigen::Matrix<T4__, Eigen::Dynamic,1>& amt,
                          const Eigen::Matrix<T5__, Eigen::Dynamic,1>& tau,
                          const std::vector<int>& addl,
                          const std::vector<int>& mdv,
                          const Eigen::Matrix<T8__, Eigen::Dynamic,Eigen::Dynamic>& init_lstate,
                          const Eigen::Matrix<T9__, Eigen::Dynamic,1>& init_time,
                          const Eigen::Matrix<T10__, Eigen::Dynamic,Eigen::Dynamic>& theta,
                          const Eigen::Matrix<T11__, Eigen::Dynamic,Eigen::Dynamic>& lscale,
                          const std::vector<T12__>& x_r,
                          const std::vector<int>& x_i, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T4__, T5__, T8__, typename boost::math::tools::promote_args<T9__, T10__, T11__, T12__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 993;
        validate_non_negative_index("dose_ind", "count_elem(evid,1, pstream__)", count_elem(evid,1, pstream__));
        vector<int> dose_ind(count_elem(evid,1, pstream__), 0);
        stan::math::fill(dose_ind, std::numeric_limits<int>::min());
        stan::math::assign(dose_ind,which_elem(evid,1, pstream__));
        current_statement_begin__ = 994;
        int N(0);
        (void) N;  // dummy to suppress unused var warning

        stan::math::fill(N, std::numeric_limits<int>::min());
        stan::math::assign(N,num_elements(time));
        current_statement_begin__ = 995;
        validate_non_negative_index("states", "N", N);
        validate_non_negative_index("states", "cols(init_lstate)", cols(init_lstate));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  states(static_cast<Eigen::VectorXd::Index>(N),static_cast<Eigen::VectorXd::Index>(cols(init_lstate)));
        (void) states;  // dummy to suppress unused var warning

        stan::math::initialize(states, DUMMY_VAR__);
        stan::math::fill(states,DUMMY_VAR__);
        current_statement_begin__ = 996;
        validate_non_negative_index("obs_states", "N", N);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  obs_states(static_cast<Eigen::VectorXd::Index>(N));
        (void) obs_states;  // dummy to suppress unused var warning

        stan::math::initialize(obs_states, DUMMY_VAR__);
        stan::math::fill(obs_states,DUMMY_VAR__);


        current_statement_begin__ = 998;
        stan::math::assign(states, evaluate_model(rle_int(stan::model::rvalue(id, stan::model::cons_list(stan::model::index_multi(dose_ind), stan::model::nil_index_list()), "id"), pstream__),stan::math::log(stan::model::rvalue(amt, stan::model::cons_list(stan::model::index_multi(dose_ind), stan::model::nil_index_list()), "amt")),stan::model::rvalue(cmt, stan::model::cons_list(stan::model::index_multi(dose_ind), stan::model::nil_index_list()), "cmt"),stan::model::rvalue(time, stan::model::cons_list(stan::model::index_multi(dose_ind), stan::model::nil_index_list()), "time"),stan::model::rvalue(tau, stan::model::cons_list(stan::model::index_multi(dose_ind), stan::model::nil_index_list()), "tau"),stan::model::rvalue(addl, stan::model::cons_list(stan::model::index_multi(dose_ind), stan::model::nil_index_list()), "addl"),init_lstate,init_time,rle_int(id, pstream__),time,theta,lscale,x_r,x_i, pstream__));
        current_statement_begin__ = 1004;
        for (int i = 1; i <= N; ++i) {
            current_statement_begin__ = 1005;
            stan::model::assign(obs_states, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        get_base1(states,i,get_base1(cmt,i,"cmt",1),"states",1), 
                        "assigning variable obs_states");
        }
        current_statement_begin__ = 1007;
        return stan::math::promote_scalar<fun_return_scalar_t__>(obs_states);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct evaluate_model_nm_cmt_functor__ {
    template <typename T1__, typename T4__, typename T5__, typename T8__, typename T9__, typename T10__, typename T11__, typename T12__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T4__, T5__, T8__, typename boost::math::tools::promote_args<T9__, T10__, T11__, T12__>::type>::type, Eigen::Dynamic,1>
    operator()(const std::vector<int>& id,
                          const Eigen::Matrix<T1__, Eigen::Dynamic,1>& time,
                          const std::vector<int>& cmt,
                          const std::vector<int>& evid,
                          const Eigen::Matrix<T4__, Eigen::Dynamic,1>& amt,
                          const Eigen::Matrix<T5__, Eigen::Dynamic,1>& tau,
                          const std::vector<int>& addl,
                          const std::vector<int>& mdv,
                          const Eigen::Matrix<T8__, Eigen::Dynamic,Eigen::Dynamic>& init_lstate,
                          const Eigen::Matrix<T9__, Eigen::Dynamic,1>& init_time,
                          const Eigen::Matrix<T10__, Eigen::Dynamic,Eigen::Dynamic>& theta,
                          const Eigen::Matrix<T11__, Eigen::Dynamic,Eigen::Dynamic>& lscale,
                          const std::vector<T12__>& x_r,
                          const std::vector<int>& x_i, std::ostream* pstream__) const {
        return evaluate_model_nm_cmt(id, time, cmt, evid, amt, tau, addl, mdv, init_lstate, init_time, theta, lscale, x_r, x_i, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic,Eigen::Dynamic>
pk_system(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& lref,
              const Eigen::Matrix<T1__, Eigen::Dynamic,1>& Dt,
              const Eigen::Matrix<T2__, Eigen::Dynamic,1>& theta,
              const std::vector<T3__>& x_r,
              const std::vector<int>& x_i, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 1014;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pk_1cmt_metabolite_depot(stan::model::rvalue(lref, stan::model::cons_list(stan::model::index_min_max(1, 3), stan::model::nil_index_list()), "lref"),Dt,get_base1(theta,1,"theta",1),get_base1(theta,2,"theta",1),get_base1(theta,2,"theta",1),0,0, pstream__));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct pk_system_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& lref,
              const Eigen::Matrix<T1__, Eigen::Dynamic,1>& Dt,
              const Eigen::Matrix<T2__, Eigen::Dynamic,1>& theta,
              const std::vector<T3__>& x_r,
              const std::vector<int>& x_i, std::ostream* pstream__) const {
        return pk_system(lref, Dt, theta, x_r, x_i, pstream__);
    }
};

template <typename T0__, typename T1__, typename T3__, typename T4__, typename T6__, typename T7__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T3__, T4__, typename boost::math::tools::promote_args<T6__, T7__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
pk_system_addl(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& lref,
                   const Eigen::Matrix<T1__, Eigen::Dynamic,1>& Dt,
                   const int& cmt,
                   const T3__& lamt,
                   const T4__& tau,
                   const int& n,
                   const Eigen::Matrix<T6__, Eigen::Dynamic,1>& theta,
                   const std::vector<T7__>& x_r,
                   const std::vector<int>& x_i, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T3__, T4__, typename boost::math::tools::promote_args<T6__, T7__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1022;
        validate_non_negative_index("lstate", "num_elements(Dt)", num_elements(Dt));
        validate_non_negative_index("lstate", "num_elements(lref)", num_elements(lref));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  lstate(static_cast<Eigen::VectorXd::Index>(num_elements(Dt)),static_cast<Eigen::VectorXd::Index>(num_elements(lref)));
        (void) lstate;  // dummy to suppress unused var warning

        stan::math::initialize(lstate, DUMMY_VAR__);
        stan::math::fill(lstate,DUMMY_VAR__);
        current_statement_begin__ = 1023;
        validate_non_negative_index("lstate_mdose", "num_elements(Dt)", num_elements(Dt));
        validate_non_negative_index("lstate_mdose", "num_elements(lref)", num_elements(lref));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  lstate_mdose(static_cast<Eigen::VectorXd::Index>(num_elements(Dt)),static_cast<Eigen::VectorXd::Index>(num_elements(lref)));
        (void) lstate_mdose;  // dummy to suppress unused var warning

        stan::math::initialize(lstate_mdose, DUMMY_VAR__);
        stan::math::fill(lstate_mdose,DUMMY_VAR__);
        current_statement_begin__ = 1024;
        validate_non_negative_index("lref_mdose", "num_elements(lref)", num_elements(lref));
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  lref_mdose(static_cast<Eigen::VectorXd::Index>(num_elements(lref)));
        (void) lref_mdose;  // dummy to suppress unused var warning

        stan::math::initialize(lref_mdose, DUMMY_VAR__);
        stan::math::fill(lref_mdose,DUMMY_VAR__);
        current_statement_begin__ = 1025;
        int S(0);
        (void) S;  // dummy to suppress unused var warning

        stan::math::fill(S, std::numeric_limits<int>::min());


        current_statement_begin__ = 1028;
        stan::math::assign(lstate, pk_system(lref,Dt,theta,x_r,x_i, pstream__));
        current_statement_begin__ = 1031;
        stan::math::assign(S, num_elements(lref));
        current_statement_begin__ = 1032;
        stan::math::assign(lref_mdose, rep_vector(-(35),S));
        current_statement_begin__ = 1033;
        stan::model::assign(lref_mdose, 
                    stan::model::cons_list(stan::model::index_uni(cmt), stan::model::nil_index_list()), 
                    lamt, 
                    "assigning variable lref_mdose");
        current_statement_begin__ = 1045;
        stan::math::assign(lstate_mdose, pk_1cmt_metabolite_depot(stan::model::rvalue(lref_mdose, stan::model::cons_list(stan::model::index_min_max(1, 3), stan::model::nil_index_list()), "lref_mdose"),subtract(Dt,(tau * n)),get_base1(theta,1,"theta",1),get_base1(theta,2,"theta",1),get_base1(theta,2,"theta",1),tau,(n + 1), pstream__));
        current_statement_begin__ = 1049;
        for (int s = 1; s <= S; ++s) {
            current_statement_begin__ = 1050;
            for (int t = 1; t <= num_elements(Dt); ++t) {
                current_statement_begin__ = 1051;
                stan::model::assign(lstate, 
                            stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(s), stan::model::nil_index_list())), 
                            stan::model::deep_copy(log_sum_exp(get_base1(lstate_mdose,t,s,"lstate_mdose",1),get_base1(lstate,t,s,"lstate",1))), 
                            "assigning variable lstate");
            }
        }
        current_statement_begin__ = 1052;
        return stan::math::promote_scalar<fun_return_scalar_t__>(lstate);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct pk_system_addl_functor__ {
    template <typename T0__, typename T1__, typename T3__, typename T4__, typename T6__, typename T7__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T3__, T4__, typename boost::math::tools::promote_args<T6__, T7__>::type>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& lref,
                   const Eigen::Matrix<T1__, Eigen::Dynamic,1>& Dt,
                   const int& cmt,
                   const T3__& lamt,
                   const T4__& tau,
                   const int& n,
                   const Eigen::Matrix<T6__, Eigen::Dynamic,1>& theta,
                   const std::vector<T7__>& x_r,
                   const std::vector<int>& x_i, std::ostream* pstream__) const {
        return pk_system_addl(lref, Dt, cmt, lamt, tau, n, theta, x_r, x_i, pstream__);
    }
};

template <typename T0__, typename T2__, typename T3__, typename T5__, typename T6__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T2__, T3__, T5__, typename boost::math::tools::promote_args<T6__>::type>::type, Eigen::Dynamic,1>
calc_ref_lscale(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& dose_amt,
                    const std::vector<int>& dose_cmt,
                    const Eigen::Matrix<T2__, Eigen::Dynamic,1>& dose_time,
                    const Eigen::Matrix<T3__, Eigen::Dynamic,1>& dose_tau,
                    const std::vector<int>& dose_addl,
                    const T5__& time,
                    const Eigen::Matrix<T6__, Eigen::Dynamic,1>& theta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T2__, T3__, T5__, typename boost::math::tools::promote_args<T6__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1077;
        int num_dosing(0);
        (void) num_dosing;  // dummy to suppress unused var warning

        stan::math::fill(num_dosing, std::numeric_limits<int>::min());
        stan::math::assign(num_dosing,rows(dose_amt));
        current_statement_begin__ = 1078;
        validate_non_negative_index("dose_lamt", "num_dosing", num_dosing);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  dose_lamt(static_cast<Eigen::VectorXd::Index>(num_dosing));
        (void) dose_lamt;  // dummy to suppress unused var warning

        stan::math::initialize(dose_lamt, DUMMY_VAR__);
        stan::math::fill(dose_lamt,DUMMY_VAR__);
        stan::math::assign(dose_lamt,stan::math::log(dose_amt));
        current_statement_begin__ = 1079;
        validate_non_negative_index("init_lstate", "3", 3);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  init_lstate(static_cast<Eigen::VectorXd::Index>(3));
        (void) init_lstate;  // dummy to suppress unused var warning

        stan::math::initialize(init_lstate, DUMMY_VAR__);
        stan::math::fill(init_lstate,DUMMY_VAR__);
        stan::math::assign(init_lstate,rep_vector(-(25.0),3));
        current_statement_begin__ = 1080;
        validate_non_negative_index("lscale", "3", 3);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  lscale(static_cast<Eigen::VectorXd::Index>(3));
        (void) lscale;  // dummy to suppress unused var warning

        stan::math::initialize(lscale, DUMMY_VAR__);
        stan::math::fill(lscale,DUMMY_VAR__);
        stan::math::assign(lscale,rep_vector(0.0,3));
        current_statement_begin__ = 1081;
        validate_non_negative_index("ref_lscale", "3", 3);
        Eigen::Matrix<local_scalar_t__,Eigen::Dynamic,1>  ref_lscale(static_cast<Eigen::VectorXd::Index>(3));
        (void) ref_lscale;  // dummy to suppress unused var warning

        stan::math::initialize(ref_lscale, DUMMY_VAR__);
        stan::math::fill(ref_lscale,DUMMY_VAR__);
        stan::math::assign(ref_lscale,to_vector(pk_model(dose_lamt,dose_cmt,dose_time,dose_tau,dose_addl,init_lstate,0.0,rep_vector(time,1),theta,lscale,rep_array(0.0,1),rep_array(0,1), pstream__)));


        current_statement_begin__ = 1089;
        stan::model::assign(ref_lscale, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    stan::model::deep_copy((get_base1(ref_lscale,3,"ref_lscale",1) - get_base1(theta,2,"theta",1))), 
                    "assigning variable ref_lscale");
        current_statement_begin__ = 1090;
        stan::model::assign(ref_lscale, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list()), 
                    stan::model::deep_copy((get_base1(ref_lscale,3,"ref_lscale",1) - get_base1(theta,2,"theta",1))), 
                    "assigning variable ref_lscale");
        current_statement_begin__ = 1092;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ref_lscale);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct calc_ref_lscale_functor__ {
    template <typename T0__, typename T2__, typename T3__, typename T5__, typename T6__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T2__, T3__, T5__, typename boost::math::tools::promote_args<T6__>::type>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& dose_amt,
                    const std::vector<int>& dose_cmt,
                    const Eigen::Matrix<T2__, Eigen::Dynamic,1>& dose_time,
                    const Eigen::Matrix<T3__, Eigen::Dynamic,1>& dose_tau,
                    const std::vector<int>& dose_addl,
                    const T5__& time,
                    const Eigen::Matrix<T6__, Eigen::Dynamic,1>& theta, std::ostream* pstream__) const {
        return calc_ref_lscale(dose_amt, dose_cmt, dose_time, dose_tau, dose_addl, time, theta, pstream__);
    }
};

template <typename T0__>
void
pretty_print(const std::vector<std::vector<T0__> >& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1096;
        validate_non_negative_index("d", "2", 2);
        vector<int> d(2, 0);
        stan::math::fill(d, std::numeric_limits<int>::min());


        current_statement_begin__ = 1097;
        stan::math::assign(d, dims(x));
        current_statement_begin__ = 1098;
        for (int m = 1; m <= get_base1(d,1,"d",1); ++m) {
            {
            current_statement_begin__ = 1099;
            validate_non_negative_index("rv", "get_base1(d,2,\"d\",1)", get_base1(d,2,"d",1));
            Eigen::Matrix<local_scalar_t__,1,Eigen::Dynamic>  rv(static_cast<Eigen::VectorXd::Index>(get_base1(d,2,"d",1)));
            (void) rv;  // dummy to suppress unused var warning

            stan::math::initialize(rv, DUMMY_VAR__);
            stan::math::fill(rv,DUMMY_VAR__);


            current_statement_begin__ = 1100;
            for (int n = 1; n <= get_base1(d,2,"d",1); ++n) {
                current_statement_begin__ = 1101;
                stan::model::assign(rv, 
                            stan::model::cons_list(stan::model::index_uni(n), stan::model::nil_index_list()), 
                            (stan::math::round((1000 * get_base1(get_base1(x,m,"x",1),n,"x",2))) / 1000.0), 
                            "assigning variable rv");
            }
            current_statement_begin__ = 1102;
            if (pstream__) {
                stan_print(pstream__,"row ");
                stan_print(pstream__,m);
                stan_print(pstream__," = ");
                stan_print(pstream__,rv);
                *pstream__ << std::endl;
            }
            }
        }
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct pretty_print_functor__ {
    template <typename T0__>
        void
    operator()(const std::vector<std::vector<T0__> >& x, std::ostream* pstream__) const {
        return pretty_print(x, pstream__);
    }
};

 } 
// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
int
rle_elem_count(const std::vector<int>& set, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::rle_elem_count(set, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
std::vector<int>
rle_int(const std::vector<int>& set, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::rle_int(set, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
std::vector<int>
seq_int(const int& start,
            const int& end, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::seq_int(start, end, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
std::vector<int>
rep_each(const std::vector<int>& set,
             const std::vector<int>& each, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::rep_each(set, each, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
double
log_diff_exp_abs(const double& la,
                     const double& lb, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::log_diff_exp_abs<double, double>(la, lb, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
std::vector<int>
find_interval_slow(const Eigen::Matrix<double, Eigen::Dynamic,1>& x,
                       const Eigen::Matrix<double, Eigen::Dynamic,1>& sorted, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::find_interval_slow<double, double>(x, sorted, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
int
find_interval_elem(const double& x,
                       const Eigen::Matrix<double, Eigen::Dynamic,1>& sorted,
                       const int& start_ind, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::find_interval_elem<double, double>(x, sorted, start_ind, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
std::vector<int>
find_interval(const Eigen::Matrix<double, Eigen::Dynamic,1>& x,
                  const Eigen::Matrix<double, Eigen::Dynamic,1>& sorted, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::find_interval<double, double>(x, sorted, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
std::vector<int>
find_interval_asc(const Eigen::Matrix<double, Eigen::Dynamic,1>& x,
                      const Eigen::Matrix<double, Eigen::Dynamic,1>& sorted, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::find_interval_asc<double, double>(x, sorted, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
std::vector<int>
find_interval_blocked(const std::vector<int>& vals_M,
                          const Eigen::Matrix<double, Eigen::Dynamic,1>& vals,
                          const std::vector<int>& sorted_M,
                          const Eigen::Matrix<double, Eigen::Dynamic,1>& sorted, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::find_interval_blocked<double, double>(vals_M, vals, sorted_M, sorted, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
int
count_elem(const std::vector<int>& test,
               const int& elem, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::count_elem(test, elem, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
std::vector<int>
count_elems(const std::vector<int>& test,
                const std::vector<int>& elems, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::count_elems(test, elems, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
std::vector<int>
which_elem(const std::vector<int>& test,
               const int& elem, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::which_elem(test, elem, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
int
floor_div_int(const double& fac,
                  const double& div, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::floor_div_int<double, double>(fac, div, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
std::vector<int>
count_obs_event_free(const std::vector<int>& obs_timeRank,
                         const int& ndose, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::count_obs_event_free(obs_timeRank, ndose, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
std::vector<int>
count_obs_event_free_blocked(const std::vector<int>& M,
                                 const std::vector<int>& obs_timeRank,
                                 const std::vector<int>& ndose, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::count_obs_event_free_blocked(M, obs_timeRank, ndose, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
std::vector<int>
subset_int(const std::vector<int>& cand,
               const std::vector<int>& ind_set, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::subset_int(cand, ind_set, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
Eigen::Matrix<double, Eigen::Dynamic,1>
subset_vec(const Eigen::Matrix<double, Eigen::Dynamic,1>& cand,
               const std::vector<int>& ind_set, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::subset_vec<double>(cand, ind_set, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>
subset_matrix(const Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>& cand,
                  const std::vector<int>& ind_set, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::subset_matrix<double>(cand, ind_set, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
void
check_ids(const std::vector<int>& id, std::ostream* pstream__ = nullptr){
  
user_cef2cb265cf917e6460cb551e02344a8::check_ids(id, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
void
check_addl_dosing(const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_time,
                      const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_tau,
                      const std::vector<int>& dose_addl, std::ostream* pstream__ = nullptr){
  
user_cef2cb265cf917e6460cb551e02344a8::check_addl_dosing<double, double>(dose_time, dose_tau, dose_addl, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
void
check_addl_dosing_blocked(const std::vector<int>& dose_M,
                              const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_time,
                              const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_tau,
                              const std::vector<int>& dose_addl, std::ostream* pstream__ = nullptr){
  
user_cef2cb265cf917e6460cb551e02344a8::check_addl_dosing_blocked<double, double>(dose_M, dose_time, dose_tau, dose_addl, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
std::vector<int>
make_slice_index(const std::vector<int>& S, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::make_slice_index(S, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
std::vector<int>
count_dose_given(const Eigen::Matrix<double, Eigen::Dynamic,1>& time,
                     const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_time,
                     const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_tau,
                     const std::vector<int>& dose_addl, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::count_dose_given<double, double, double>(time, dose_time, dose_tau, dose_addl, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
std::vector<int>
count_dose_given_blocked(const std::vector<int>& M,
                             const Eigen::Matrix<double, Eigen::Dynamic,1>& time,
                             const std::vector<int>& M_dose,
                             const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_time,
                             const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_tau,
                             const std::vector<int>& dose_addl, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::count_dose_given_blocked<double, double, double>(M, time, M_dose, dose_time, dose_tau, dose_addl, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>
evolve_lsystem(const int& S,
                   const Eigen::Matrix<double, Eigen::Dynamic,1>& Dt,
                   const Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>& coefs,
                   const std::vector<int>& coefs_map, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::evolve_lsystem<double, double>(S, Dt, coefs, coefs_map, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
double
lgeometric_series(const double& la,
                      const int& n, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::lgeometric_series<double>(la, n, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>
pk_1cmt_metabolite_depot(const Eigen::Matrix<double, Eigen::Dynamic,1>& lref,
                             const Eigen::Matrix<double, Eigen::Dynamic,1>& Dt,
                             const double& lk1,
                             const double& lk12,
                             const double& lk20,
                             const double& tau,
                             const int& n, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::pk_1cmt_metabolite_depot<double, double, double, double, double, double>(lref, Dt, lk1, lk12, lk20, tau, n, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>
pk_1cmt_metabolite(const Eigen::Matrix<double, Eigen::Dynamic,1>& lref,
                       const Eigen::Matrix<double, Eigen::Dynamic,1>& Dt,
                       const double& lk1,
                       const double& lk12,
                       const double& lk20,
                       const double& tau,
                       const int& n, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::pk_1cmt_metabolite<double, double, double, double, double, double>(lref, Dt, lk1, lk12, lk20, tau, n, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
Eigen::Matrix<double, Eigen::Dynamic,1>
pk_1cmt_metabolite_metrics(const double& tau,
                               const double& lk1,
                               const double& lk12,
                               const double& lk20, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::pk_1cmt_metabolite_metrics<double, double, double, double>(tau, lk1, lk12, lk20, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>
pk_oral_2cmt(const Eigen::Matrix<double, Eigen::Dynamic,1>& state0,
                 const Eigen::Matrix<double, Eigen::Dynamic,1>& Dt,
                 const double& lka,
                 const double& lalphaR,
                 const double& lbetaR,
                 const double& lA,
                 const double& lB, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::pk_oral_2cmt<double, double, double, double, double, double, double>(state0, Dt, lka, lalphaR, lbetaR, lA, lB, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>
pk_model_fast(const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_lamt,
                  const std::vector<int>& dose_cmt,
                  const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_time,
                  const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_tau,
                  const std::vector<int>& dose_addl,
                  const std::vector<int>& dose_next_obs,
                  const Eigen::Matrix<double, Eigen::Dynamic,1>& init_lstate,
                  const double& init_time,
                  const Eigen::Matrix<double, Eigen::Dynamic,1>& obs_time,
                  const std::vector<int>& obs_timeRank,
                  const std::vector<int>& obs_dose_given,
                  const Eigen::Matrix<double, Eigen::Dynamic,1>& theta,
                  const Eigen::Matrix<double, Eigen::Dynamic,1>& lscale,
                  const std::vector<double>& x_r,
                  const std::vector<int>& x_i, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::pk_model_fast<double, double, double, double, double, double, double, double, double>(dose_lamt, dose_cmt, dose_time, dose_tau, dose_addl, dose_next_obs, init_lstate, init_time, obs_time, obs_timeRank, obs_dose_given, theta, lscale, x_r, x_i, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>
pk_model(const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_lamt,
             const std::vector<int>& dose_cmt,
             const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_time,
             const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_tau,
             const std::vector<int>& dose_addl,
             const Eigen::Matrix<double, Eigen::Dynamic,1>& init_lstate,
             const double& init_time,
             const Eigen::Matrix<double, Eigen::Dynamic,1>& obs_time,
             const Eigen::Matrix<double, Eigen::Dynamic,1>& theta,
             const Eigen::Matrix<double, Eigen::Dynamic,1>& lscale,
             const std::vector<double>& x_r,
             const std::vector<int>& x_i, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::pk_model<double, double, double, double, double, double, double, double, double>(dose_lamt, dose_cmt, dose_time, dose_tau, dose_addl, init_lstate, init_time, obs_time, theta, lscale, x_r, x_i, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>
evaluate_model_fast(const std::vector<int>& dose_M,
                        const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_lamt,
                        const std::vector<int>& dose_cmt,
                        const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_time,
                        const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_tau,
                        const std::vector<int>& dose_addl,
                        const std::vector<int>& dose_next_obs,
                        const Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>& init_lstate,
                        const Eigen::Matrix<double, Eigen::Dynamic,1>& init_time,
                        const std::vector<int>& obs_M,
                        const Eigen::Matrix<double, Eigen::Dynamic,1>& obs_time,
                        const std::vector<int>& obs_timeRank,
                        const std::vector<int>& obs_dose_given,
                        const Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>& theta,
                        const Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>& lscale,
                        const std::vector<double>& x_r,
                        const std::vector<int>& x_i, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::evaluate_model_fast<double, double, double, double, double, double, double, double, double>(dose_M, dose_lamt, dose_cmt, dose_time, dose_tau, dose_addl, dose_next_obs, init_lstate, init_time, obs_M, obs_time, obs_timeRank, obs_dose_given, theta, lscale, x_r, x_i, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
Eigen::Matrix<double, Eigen::Dynamic,1>
evaluate_model_fast_cmt(const std::vector<int>& dose_M,
                            const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_lamt,
                            const std::vector<int>& dose_cmt,
                            const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_time,
                            const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_tau,
                            const std::vector<int>& dose_addl,
                            const std::vector<int>& dose_next_obs,
                            const Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>& init_lstate,
                            const Eigen::Matrix<double, Eigen::Dynamic,1>& init_time,
                            const std::vector<int>& obs_M,
                            const Eigen::Matrix<double, Eigen::Dynamic,1>& obs_time,
                            const std::vector<int>& obs_timeRank,
                            const std::vector<int>& obs_dose_given,
                            const std::vector<int>& obs_cmt,
                            const Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>& theta,
                            const Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>& lscale,
                            const std::vector<double>& x_r,
                            const std::vector<int>& x_i, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::evaluate_model_fast_cmt<double, double, double, double, double, double, double, double, double>(dose_M, dose_lamt, dose_cmt, dose_time, dose_tau, dose_addl, dose_next_obs, init_lstate, init_time, obs_M, obs_time, obs_timeRank, obs_dose_given, obs_cmt, theta, lscale, x_r, x_i, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>
evaluate_model(const std::vector<int>& dose_M,
                   const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_lamt,
                   const std::vector<int>& dose_cmt,
                   const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_time,
                   const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_tau,
                   const std::vector<int>& dose_addl,
                   const Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>& init_lstate,
                   const Eigen::Matrix<double, Eigen::Dynamic,1>& init_time,
                   const std::vector<int>& obs_M,
                   const Eigen::Matrix<double, Eigen::Dynamic,1>& obs_time,
                   const Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>& theta,
                   const Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>& lscale,
                   const std::vector<double>& x_r,
                   const std::vector<int>& x_i, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::evaluate_model<double, double, double, double, double, double, double, double, double>(dose_M, dose_lamt, dose_cmt, dose_time, dose_tau, dose_addl, init_lstate, init_time, obs_M, obs_time, theta, lscale, x_r, x_i, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>
evaluate_model_nm(const std::vector<int>& id,
                      const Eigen::Matrix<double, Eigen::Dynamic,1>& time,
                      const std::vector<int>& cmt,
                      const std::vector<int>& evid,
                      const Eigen::Matrix<double, Eigen::Dynamic,1>& amt,
                      const Eigen::Matrix<double, Eigen::Dynamic,1>& tau,
                      const std::vector<int>& addl,
                      const std::vector<int>& mdv,
                      const Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>& init_lstate,
                      const Eigen::Matrix<double, Eigen::Dynamic,1>& init_time,
                      const Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>& theta,
                      const Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>& lscale,
                      const std::vector<double>& x_r,
                      const std::vector<int>& x_i, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::evaluate_model_nm<double, double, double, double, double, double, double, double>(id, time, cmt, evid, amt, tau, addl, mdv, init_lstate, init_time, theta, lscale, x_r, x_i, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
Eigen::Matrix<double, Eigen::Dynamic,1>
evaluate_model_nm_cmt(const std::vector<int>& id,
                          const Eigen::Matrix<double, Eigen::Dynamic,1>& time,
                          const std::vector<int>& cmt,
                          const std::vector<int>& evid,
                          const Eigen::Matrix<double, Eigen::Dynamic,1>& amt,
                          const Eigen::Matrix<double, Eigen::Dynamic,1>& tau,
                          const std::vector<int>& addl,
                          const std::vector<int>& mdv,
                          const Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>& init_lstate,
                          const Eigen::Matrix<double, Eigen::Dynamic,1>& init_time,
                          const Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>& theta,
                          const Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>& lscale,
                          const std::vector<double>& x_r,
                          const std::vector<int>& x_i, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::evaluate_model_nm_cmt<double, double, double, double, double, double, double, double>(id, time, cmt, evid, amt, tau, addl, mdv, init_lstate, init_time, theta, lscale, x_r, x_i, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>
pk_system(const Eigen::Matrix<double, Eigen::Dynamic,1>& lref,
              const Eigen::Matrix<double, Eigen::Dynamic,1>& Dt,
              const Eigen::Matrix<double, Eigen::Dynamic,1>& theta,
              const std::vector<double>& x_r,
              const std::vector<int>& x_i, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::pk_system<double, double, double, double>(lref, Dt, theta, x_r, x_i, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
Eigen::Matrix<double, Eigen::Dynamic,Eigen::Dynamic>
pk_system_addl(const Eigen::Matrix<double, Eigen::Dynamic,1>& lref,
                   const Eigen::Matrix<double, Eigen::Dynamic,1>& Dt,
                   const int& cmt,
                   const double& lamt,
                   const double& tau,
                   const int& n,
                   const Eigen::Matrix<double, Eigen::Dynamic,1>& theta,
                   const std::vector<double>& x_r,
                   const std::vector<int>& x_i, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::pk_system_addl<double, double, double, double, double, double>(lref, Dt, cmt, lamt, tau, n, theta, x_r, x_i, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
Eigen::Matrix<double, Eigen::Dynamic,1>
calc_ref_lscale(const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_amt,
                    const std::vector<int>& dose_cmt,
                    const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_time,
                    const Eigen::Matrix<double, Eigen::Dynamic,1>& dose_tau,
                    const std::vector<int>& dose_addl,
                    const double& time,
                    const Eigen::Matrix<double, Eigen::Dynamic,1>& theta, std::ostream* pstream__ = nullptr){
  return 
user_cef2cb265cf917e6460cb551e02344a8::calc_ref_lscale<double, double, double, double, double>(dose_amt, dose_cmt, dose_time, dose_tau, dose_addl, time, theta, pstream__);
}

// [[Rcpp::depends(rstan)]]
// [[Rcpp::export]]
void
pretty_print(const std::vector<std::vector<double> >& x, std::ostream* pstream__ = nullptr){
  
user_cef2cb265cf917e6460cb551e02344a8::pretty_print<double>(x, pstream__);
}


